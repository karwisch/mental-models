<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Models Decision Navigator - Untangled Narrative</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --teal: #1B7F92;
            --mauve: #b36278;
            --light-teal: #2a9fb5;
            --light-mauve: #c47a95;
            --cream: #f8f6f3;
            --charcoal: #2a2a2a;
            --warm-white: #fefdfb;
            --shadow-teal: rgba(27, 127, 146, 0.15);
            --shadow-mauve: rgba(179, 98, 120, 0.15);
            --diagnostic-color: #1B7F92;
            --evaluative-color: #4CAF50;
            --protective-color: #b36278;
            --generative-color: #FF9800;
            --implementation-color: #9C27B0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, var(--warm-white) 100%);
            color: var(--charcoal);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* App Layout with Persistent Sidebar */
        .app-layout {
            display: flex;
            min-height: 100vh;
        }

        /* Persistent Left Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 100;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
        }

        .sidebar-header {
            padding: 1.25rem;
            border-bottom: 1px solid #e0e0e0;
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.08), white);
        }

        .sidebar-greeting {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--charcoal);
            margin-bottom: 0.25rem;
        }

        .sidebar-subgreeting {
            font-size: 0.8rem;
            color: var(--teal);
            font-weight: 500;
        }

        .sidebar-nav {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
        }

        .sidebar-section {
            margin-bottom: 1.5rem;
        }

        .sidebar-section-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--charcoal);
            opacity: 0.5;
            padding: 0 1.25rem;
            margin-bottom: 0.5rem;
        }

        .sidebar-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 1.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .sidebar-item:hover {
            background: var(--cream);
        }

        .sidebar-item.active {
            background: linear-gradient(90deg, rgba(27, 127, 146, 0.1), transparent);
            border-left-color: var(--teal);
        }

        .sidebar-item-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .sidebar-item-content {
            flex: 1;
        }

        .sidebar-item-label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--charcoal);
        }

        .sidebar-item-sublabel {
            font-size: 0.7rem;
            color: var(--charcoal);
            opacity: 0.6;
        }

        /* Phase Items in Sidebar */
        .phase-sidebar-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .phase-sidebar-item:hover {
            background: var(--cream);
        }

        .phase-sidebar-item.active {
            border-left-color: var(--teal);
            background: linear-gradient(90deg, rgba(27, 127, 146, 0.08), transparent);
        }

        .phase-sidebar-item.completed {
            opacity: 0.7;
        }

        .phase-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: 700;
            color: white;
        }

        .phase-icon.diagnostic { background: var(--diagnostic-color); }
        .phase-icon.evaluative { background: var(--evaluative-color); }
        .phase-icon.protective { background: var(--protective-color); }
        .phase-icon.generative { background: var(--generative-color); }
        .phase-icon.implementation { background: var(--implementation-color); }

        .phase-sidebar-content {
            flex: 1;
        }

        .phase-sidebar-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--charcoal);
            margin-bottom: 0.2rem;
        }

        .phase-progress-bar {
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
        }

        .phase-progress-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .phase-progress-fill.diagnostic { background: var(--diagnostic-color); }
        .phase-progress-fill.evaluative { background: var(--evaluative-color); }
        .phase-progress-fill.protective { background: var(--protective-color); }
        .phase-progress-fill.generative { background: var(--generative-color); }
        .phase-progress-fill.implementation { background: var(--implementation-color); }

        .phase-progress-text {
            font-size: 0.65rem;
            color: var(--charcoal);
            opacity: 0.6;
            margin-top: 0.2rem;
        }

        /* Status Badges */
        .status-badge {
            font-size: 0.6rem;
            font-weight: 700;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .status-badge.not-started {
            background: #e0e0e0;
            color: #666;
        }

        .status-badge.in-progress {
            background: rgba(27, 127, 146, 0.15);
            color: var(--teal);
        }

        .status-badge.completed {
            background: rgba(76, 175, 80, 0.15);
            color: #4CAF50;
        }

        /* Sidebar Footer */
        .sidebar-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid #e0e0e0;
            background: var(--cream);
        }

        .sidebar-footer-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.6rem;
            background: var(--teal);
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sidebar-footer-btn:hover {
            background: var(--light-teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.3);
        }

        /* Main Content Area - adjusted for sidebar */
        .main-area {
            flex: 1;
            margin-left: 280px;
            padding: 1.5rem;
            min-height: 100vh;
        }

        /* Quick Actions Bar */
        .quick-actions {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .quick-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            color: var(--charcoal);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-action-btn:hover {
            border-color: var(--teal);
            color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
        }

        .quick-action-btn.primary {
            background: var(--teal);
            border-color: var(--teal);
            color: white;
        }

        .quick-action-btn.primary:hover {
            background: var(--light-teal);
        }

        /* Dashboard Cards */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .dashboard-card {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e8e8e8;
        }

        .dashboard-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .dashboard-card-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--charcoal);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dashboard-card-action {
            font-size: 0.7rem;
            color: var(--teal);
            cursor: pointer;
            font-weight: 600;
        }

        .dashboard-card-action:hover {
            text-decoration: underline;
        }

        /* Progress Overview Card */
        .progress-overview {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .progress-phase-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .progress-phase-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
        }

        .progress-phase-info {
            flex: 1;
        }

        .progress-phase-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--charcoal);
            margin-bottom: 0.2rem;
        }

        .progress-phase-bar {
            height: 6px;
            background: #e8e8e8;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-phase-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-phase-percent {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--charcoal);
            min-width: 35px;
            text-align: right;
        }

        /* Right Panel for Notes/Log */
        .right-panel {
            position: fixed;
            top: 0;
            right: -380px;
            width: 380px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
            transition: right 0.3s ease;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .right-panel.open {
            right: 0;
        }

        .right-panel-toggle {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--teal);
            color: white;
            border: none;
            padding: 1rem 0.5rem;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            z-index: 99;
            transition: all 0.3s ease;
        }

        .right-panel-toggle:hover {
            background: var(--light-teal);
            padding-right: 0.75rem;
        }

        .right-panel-toggle.active {
            right: 380px;
        }

        /* Panel Tabs */
        .panel-tabs {
            display: flex;
            gap: 0;
        }

        .panel-tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--charcoal);
            opacity: 0.5;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .panel-tab:hover {
            opacity: 0.8;
        }

        .panel-tab.active {
            opacity: 1;
            color: var(--teal);
            border-bottom-color: var(--teal);
        }

        .panel-section {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .panel-section.active {
            display: flex;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            min-height: auto;
            position: relative;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 0.25rem;
        }

        .header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--charcoal);
            margin-bottom: 0.2rem;
        }

        .header p {
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.65;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            flex: 1;
            margin-left: 50px; /* Space for left toggle button */
            margin-right: 50px; /* Space for right toggle button */
        }

        /* Problem Reference Banner */
        .problem-reference {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.08), white);
            border: 1px solid var(--teal);
            border-left: 4px solid var(--teal);
            border-radius: 8px;
            padding: 1rem;
            display: none;
            margin-bottom: 0.5rem;
        }

        .problem-reference.visible {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .problem-reference-header {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            color: var(--teal);
            margin-bottom: 0.5rem;
            opacity: 0.8;
        }

        .problem-reference-text {
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--charcoal);
            font-weight: 500;
        }

        /* Problem Type Selection */
        .problem-type-selector {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin-bottom: 1rem;
            display: none;
        }

        .problem-type-selector.visible {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        .problem-type-selector h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            color: var(--charcoal);
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .problem-type-selector p {
            font-size: 0.8rem;
            color: var(--charcoal);
            opacity: 0.7;
            margin-bottom: 1rem;
        }

        .problem-types-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .problem-type-card {
            padding: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .problem-type-card:hover {
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
            transform: translateY(-1px);
        }

        .problem-type-card.selected {
            border-color: var(--teal);
            border-width: 2px;
            background: rgba(27, 127, 146, 0.03);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.2);
        }

        .problem-type-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.4rem;
            color: var(--charcoal);
        }

        .problem-type-description {
            font-size: 0.75rem;
            line-height: 1.3;
            color: var(--charcoal);
            opacity: 0.75;
        }

        .continue-btn {
            margin-top: 1rem;
            padding: 0.6rem 1.5rem;
            background: var(--teal);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: none;
        }

        .continue-btn.visible {
            display: inline-block;
        }

        .continue-btn:hover {
            background: var(--light-teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.3);
        }

        /* Toggle Buttons */
        .toggle-buttons {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .toggle-btn {
            background: var(--teal);
            color: white;
            border: none;
            padding: 0.75rem 0.5rem;
            border-radius: 8px 0 0 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .toggle-btn::before {
            content: '◀';
            font-size: 1rem;
            display: block;
            transition: transform 0.3s ease;
            writing-mode: horizontal-tb;
            text-orientation: upright;
        }

        .toggle-btn:hover {
            background: var(--light-teal);
            transform: translateX(-5px);
            box-shadow: -4px 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toggle-btn:hover::before {
            transform: translateX(-3px);
        }

        .toggle-btn.active {
            background: var(--charcoal);
            transform: translateX(-5px);
        }

        .toggle-btn.active::before {
            content: '▶';
        }

        /* Left toggle buttons (for notepad) */
        .toggle-buttons-left {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .toggle-btn-left {
            background: var(--mauve);
            color: white;
            border: none;
            padding: 0.75rem 0.5rem;
            border-radius: 0 8px 8px 0;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .toggle-btn-left::before {
            content: '◀';
            font-size: 1rem;
            display: block;
            transition: transform 0.3s ease;
            writing-mode: horizontal-tb;
            text-orientation: upright;
        }

        .toggle-btn-left:hover {
            background: var(--light-mauve);
            transform: rotate(180deg) translateX(-5px);
            box-shadow: 2px 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toggle-btn-left.active {
            background: var(--charcoal);
            transform: rotate(180deg) translateX(-5px);
        }

        .toggle-btn-left.active::before {
            content: '▶';
        }

        /* Right Panel - Decision Log */
        .panel-right {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
            transition: right 0.3s ease;
            z-index: 90;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-right.open {
            right: 0;
        }

        /* Left Panel - Notepad */
        .panel-left {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: white;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15);
            transition: left 0.3s ease;
            z-index: 90;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-left.open {
            left: 0;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: var(--cream);
            flex-shrink: 0;
        }

        .panel-header h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
        }

        .panel-header-right h3 {
            color: var(--teal);
        }

        .panel-header-left h3 {
            color: var(--mauve);
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--charcoal);
            opacity: 0.6;
            transition: opacity 0.3s ease;
            padding: 0;
            line-height: 1;
        }

        .panel-close:hover {
            opacity: 1;
        }

        .panel-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Responsive main content */
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
            position: relative;
            transition: margin 0.3s ease, max-width 0.3s ease;
        }

        body.panel-right-open .container {
            margin-right: 350px;
        }

        body.panel-left-open .container {
            margin-left: 350px;
        }

        body.panel-right-open.panel-left-open .container {
            margin-left: 350px;
            margin-right: 350px;
        }

        body.panel-right-open .toggle-buttons {
            right: 350px;
        }

        body.panel-left-open .toggle-buttons-left {
            left: 350px;
        }

        /* Phase Navigation */
        .phase-navigation {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 2px solid var(--teal);
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.5s ease, padding 0.5s ease, margin 0.5s ease;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .phase-navigation.revealed {
            max-height: 200px;
            opacity: 1;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .phase-navigation h2 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.7rem;
            color: var(--charcoal);
            margin-bottom: 0.5rem;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            opacity: 0.7;
        }

        .phase-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            justify-content: center;
        }

        .phase-btn {
            flex: 1;
            min-width: 110px;
            padding: 0.5rem 0.6rem;
            border: 2px solid;
            border-radius: 8px;
            background: white;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .phase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .phase-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .phase-btn.diagnostic {
            border-color: var(--diagnostic-color);
            color: var(--diagnostic-color);
        }

        .phase-btn.diagnostic.active {
            background: var(--diagnostic-color);
            color: white;
        }

        .phase-btn.evaluative {
            border-color: var(--evaluative-color);
            color: var(--evaluative-color);
        }

        .phase-btn.evaluative.active {
            background: var(--evaluative-color);
            color: white;
        }

        .phase-btn.protective {
            border-color: var(--protective-color);
            color: var(--protective-color);
        }

        .phase-btn.protective.active {
            background: var(--protective-color);
            color: white;
        }

        .phase-btn.generative {
            border-color: var(--generative-color);
            color: var(--generative-color);
        }

        .phase-btn.generative.active {
            background: var(--generative-color);
            color: white;
        }

        .phase-btn.implementation {
            border-color: var(--implementation-color);
            color: var(--implementation-color);
        }

        .phase-btn.implementation.active {
            background: var(--implementation-color);
            color: white;
        }

        /* Models Section */
        .models-section {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            min-height: 250px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.5s ease 0.3s, opacity 0.5s ease 0.3s, padding 0.5s ease 0.3s;
            padding-top: 0;
            padding-bottom: 0;
        }

        .models-section.revealed {
            max-height: 1000px;
            opacity: 1;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
        }

        .phase-description {
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            border-radius: 6px;
            border-left: 3px solid;
        }

        .phase-description.diagnostic {
            background: rgba(27, 127, 146, 0.08);
            border-color: var(--diagnostic-color);
        }

        .phase-description.evaluative {
            background: rgba(76, 175, 80, 0.08);
            border-color: var(--evaluative-color);
        }

        .phase-description.protective {
            background: rgba(179, 98, 120, 0.08);
            border-color: var(--protective-color);
        }

        .phase-description.generative {
            background: rgba(255, 152, 0, 0.08);
            border-color: var(--generative-color);
        }

        .phase-description.implementation {
            background: rgba(156, 39, 176, 0.08);
            border-color: var(--implementation-color);
        }

        .phase-description h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .phase-description p {
            font-size: 0.75rem;
            line-height: 1.3;
            margin-bottom: 0.15rem;
        }

        .phase-description .core-question {
            font-weight: 600;
            font-style: italic;
            margin-top: 0.25rem;
            opacity: 0.9;
            font-size: 0.75rem;
        }

        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
            gap: 0.6rem;
        }

        .model-card {
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .model-card:hover {
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
            transform: translateY(-1px);
        }

        .model-card.selected {
            border-color: var(--teal);
            border-width: 2px;
            background: rgba(27, 127, 146, 0.03);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.2);
        }

        .model-card.diagnostic.selected {
            border-color: var(--diagnostic-color);
            background: rgba(27, 127, 146, 0.05);
        }

        .model-card.evaluative.selected {
            border-color: var(--evaluative-color);
            background: rgba(76, 175, 80, 0.05);
        }

        .model-card.protective.selected {
            border-color: var(--protective-color);
            background: rgba(179, 98, 120, 0.05);
        }

        .model-card.generative.selected {
            border-color: var(--generative-color);
            background: rgba(255, 152, 0, 0.05);
        }

        .model-card.implementation.selected {
            border-color: var(--implementation-color);
            background: rgba(156, 39, 176, 0.05);
        }

        .model-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            color: var(--charcoal);
            line-height: 1.2;
        }

        .model-description {
            font-size: 0.7rem;
            line-height: 1.25;
            color: var(--charcoal);
            opacity: 0.75;
        }

        /* Work Area */
        .work-area {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: margin-top 0.5s ease;
            margin-top: 0;
        }

        .work-area.slide-down {
            margin-top: 0;
        }

        .work-area h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.75rem;
            color: var(--charcoal);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            opacity: 0.7;
        }

        /* Split-pane layout for work area */
        .work-area-content {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .work-area-content.split-pane {
            flex-wrap: nowrap;
        }

        .work-area-left {
            flex: 1;
            min-width: 300px;
        }

        .work-area-right {
            flex: 1;
            min-width: 280px;
            display: flex;
            flex-direction: column;
        }

        .work-area-content:not(.split-pane) .work-area-left {
            flex: 1 1 100%;
        }

        .work-area-content:not(.split-pane) .work-area-right {
            flex: 1 1 100%;
        }

        .response-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .response-section textarea {
            flex: 1;
            min-height: 150px;
        }

        .selected-model-display {
            padding: 0.5rem;
            background: var(--cream);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            min-height: 40px;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .selected-model-display.initial {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.1), var(--cream));
            border: 3px solid var(--teal);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 16px rgba(27, 127, 146, 0.2);
        }

        .selected-model-display.initial .instruction-text {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--teal);
            margin-bottom: 0.75rem;
            font-family: 'Montserrat', sans-serif;
            text-align: center;
        }

        .selected-model-display.initial .instruction-subtext {
            font-size: 0.9rem;
            color: var(--charcoal);
            opacity: 0.85;
            line-height: 1.6;
            text-align: center;
        }

        .selected-model-display.empty {
            opacity: 0.5;
            font-style: italic;
        }

        .model-prompt {
            font-weight: 600;
            color: var(--teal);
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
        }

        /* Expanded Model Content Styles */
        .selected-model-display.expanded {
            padding: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }

        .model-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--teal);
        }

        .model-header h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            color: var(--teal);
            margin-bottom: 0.25rem;
        }

        .model-header .model-tagline {
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.7;
            font-style: italic;
        }

        .model-section {
            margin-bottom: 1rem;
        }

        .model-section-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--mauve);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .model-section-title::before {
            content: '';
            width: 3px;
            height: 14px;
            background: var(--mauve);
            border-radius: 2px;
        }

        .model-explanation {
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--charcoal);
        }

        .model-example {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.08), rgba(27, 127, 146, 0.03));
            border-left: 3px solid var(--teal);
            padding: 0.75rem;
            border-radius: 0 6px 6px 0;
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--charcoal);
        }

        .model-prompts-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .model-prompts-list li {
            position: relative;
            padding: 0.5rem 0.75rem 0.5rem 1.5rem;
            margin-bottom: 0.5rem;
            background: var(--cream);
            border-radius: 6px;
            font-size: 0.8rem;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .model-prompts-list li::before {
            content: '→';
            position: absolute;
            left: 0.5rem;
            color: var(--teal);
            font-weight: bold;
        }

        .model-prompts-list li:hover {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.1), var(--cream));
            border-color: var(--teal);
        }

        .model-prompts-list li.selected-prompt {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.15), rgba(27, 127, 146, 0.08));
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
        }

        .model-warnings {
            background: linear-gradient(135deg, rgba(179, 98, 120, 0.08), rgba(179, 98, 120, 0.03));
            border-left: 3px solid var(--mauve);
            padding: 0.75rem;
            border-radius: 0 6px 6px 0;
        }

        .model-warnings ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .model-warnings li {
            font-size: 0.75rem;
            color: var(--charcoal);
            padding: 0.25rem 0;
            padding-left: 1.25rem;
            position: relative;
        }

        .model-warnings li::before {
            content: '⚠';
            position: absolute;
            left: 0;
            color: var(--mauve);
        }

        .model-related {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .model-related-tag {
            background: var(--cream);
            border: 1px solid #ddd;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            color: var(--charcoal);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .model-related-tag:hover {
            background: var(--teal);
            color: white;
            border-color: var(--teal);
        }

        .prompt-instruction {
            font-size: 0.75rem;
            color: var(--teal);
            opacity: 0.8;
            margin-bottom: 0.5rem;
            font-style: italic;
        }

        /* Collapsible Accordion Sections */
        .model-section.collapsible {
            margin-bottom: 0.5rem;
        }

        .model-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.5rem;
            background: var(--cream);
            border-radius: 6px;
            margin-bottom: 0;
            transition: all 0.2s ease;
        }

        .model-section-header:hover {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.1), var(--cream));
        }

        .model-section-header .model-section-title {
            margin-bottom: 0;
        }

        .model-section-toggle {
            font-size: 0.8rem;
            color: var(--teal);
            transition: transform 0.3s ease;
        }

        .model-section-header.collapsed .model-section-toggle {
            transform: rotate(-90deg);
        }

        .model-section-body {
            padding: 0.75rem;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .model-section-header.collapsed + .model-section-body {
            max-height: 0;
            padding: 0 0.75rem;
            opacity: 0;
        }

        /* Confirmation Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            color: var(--charcoal);
            margin-bottom: 0.75rem;
        }

        .modal p {
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.8;
            margin-bottom: 1.25rem;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn-cancel {
            background: var(--cream);
            color: var(--charcoal);
        }

        .modal-btn-cancel:hover {
            background: #e0e0e0;
        }

        .modal-btn-confirm {
            background: var(--mauve);
            color: white;
        }

        .modal-btn-confirm:hover {
            background: var(--light-mauve);
        }

        /* Decision Summary Section */
        .decision-summary {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.08), white);
            border: 2px solid var(--implementation-color);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 0.75rem;
            display: none;
        }

        .decision-summary.visible {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        .decision-summary h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            color: var(--implementation-color);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .decision-summary h3::before {
            content: '✓';
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--implementation-color);
            color: white;
            border-radius: 50%;
            font-size: 0.75rem;
        }

        .decision-summary-intro {
            font-size: 0.8rem;
            color: var(--charcoal);
            opacity: 0.8;
            margin-bottom: 0.75rem;
        }

        .decision-summary textarea {
            min-height: 120px;
            border-color: var(--implementation-color);
        }

        .decision-summary textarea:focus {
            border-color: var(--implementation-color);
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.1);
        }

        .decision-summary-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .btn-summary {
            background: var(--implementation-color);
            color: white;
        }

        .btn-summary:hover {
            background: #7B1FA2;
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
        }

        /* Log Sort Toggle */
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .log-header-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--charcoal);
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-sort-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            color: var(--charcoal);
            opacity: 0.7;
        }

        .log-sort-toggle button {
            background: none;
            border: 1px solid #ddd;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .log-sort-toggle button:hover {
            border-color: var(--teal);
            color: var(--teal);
        }

        .log-sort-toggle button.active {
            background: var(--teal);
            color: white;
            border-color: var(--teal);
        }

        textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.6rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.8rem;
            resize: vertical;
            transition: border-color 0.3s ease, min-height 0.3s ease;
            line-height: 1.4;
        }

        textarea.initial-entry {
            min-height: 120px;
            font-size: 0.9rem;
            border-color: var(--teal);
        }

        textarea:focus {
            outline: none;
            border-color: var(--teal);
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--teal);
            color: white;
        }

        .btn-primary:hover {
            background: var(--light-teal);
            box-shadow: 0 1px 4px rgba(27, 127, 146, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--charcoal);
            border: 1px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: var(--cream);
            border-color: var(--mauve);
            color: var(--mauve);
            box-shadow: 0 1px 4px rgba(179, 98, 120, 0.2);
        }

        .btn-warning {
            background: transparent;
            color: #FF9800;
            border: 1px solid #FF9800;
            padding: 0.5rem 0.75rem;
        }

        .btn-warning:hover {
            background: #FF9800;
            color: white;
            box-shadow: 0 1px 4px rgba(255, 152, 0, 0.3);
        }

        /* Sidebar - Now in Drawer */
        .sidebar {
            display: none; /* Hidden - content moved to drawers */
        }

        .decision-log {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .decision-log h3 {
            display: none; /* Header now in drawer-header */
        }

        .log-entries {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .log-entry {
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            cursor: move;
            transition: all 0.2s ease;
            background: white;
        }

        .log-entry:hover {
            border-color: var(--teal);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        .log-entry.diagnostic {
            border-left: 3px solid var(--diagnostic-color);
        }

        .log-entry.evaluative {
            border-left: 3px solid var(--evaluative-color);
        }

        .log-entry.protective {
            border-left: 3px solid var(--protective-color);
        }

        .log-entry.generative {
            border-left: 3px solid var(--generative-color);
        }

        .log-entry.implementation {
            border-left: 3px solid var(--implementation-color);
        }

        .log-entry.initial {
            border-left: 3px solid var(--charcoal);
            background: rgba(42, 42, 42, 0.02);
        }

        .log-entry.summary {
            border-left: 3px solid gold;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(255, 215, 0, 0.02));
        }

        .log-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .log-model-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .log-actions {
            display: flex;
            gap: 0.3rem;
        }

        .log-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .log-action-btn:hover {
            opacity: 1;
        }

        .log-prompt {
            font-size: 0.7rem;
            font-style: italic;
            color: var(--teal);
            margin-bottom: 0.4rem;
            padding: 0.3rem 0.5rem;
            background: rgba(27, 127, 146, 0.08);
            border-radius: 4px;
            line-height: 1.3;
        }

        .log-content {
            font-size: 0.7rem;
            line-height: 1.3;
            color: var(--charcoal);
            word-wrap: break-word;
        }

        .log-timestamp {
            font-size: 0.65rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        /* Notepad - Now in Drawer */
        .notepad {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .notepad h3 {
            display: none; /* Header now in drawer-header */
        }

        .notepad-area {
            flex: 1;
            padding: 0.6rem;
            border: 2px dashed var(--teal);
            border-radius: 6px;
            background: var(--cream);
            font-size: 0.75rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            min-height: 300px;
            cursor: text;
            outline: none;
        }

        .notepad-area:focus {
            border-color: var(--light-teal);
            border-style: solid;
            background: white;
        }

        .notepad-area.drag-over {
            background: rgba(27, 127, 146, 0.15);
            border-color: var(--light-teal);
        }

        .notepad-area.empty {
            opacity: 0.5;
            font-style: italic;
        }

        .notepad-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .notepad-actions button {
            flex: 1;
            padding: 0.4rem;
            border: 2px solid var(--mauve);
            background: white;
            color: var(--mauve);
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .notepad-actions button:hover {
            background: var(--mauve);
            color: white;
            transform: translateY(-2px);
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 1rem;
            opacity: 0.5;
            font-style: italic;
            font-size: 0.75rem;
        }

        /* Flying Entry Animation */
        @keyframes flyToLog {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(200px, -100px) scale(0.5) rotate(10deg);
                opacity: 0.7;
            }
            100% {
                transform: translate(400px, -200px) scale(0.2) rotate(20deg);
                opacity: 0;
            }
        }

        .flying-entry {
            position: fixed;
            background: white;
            border: 2px solid var(--charcoal);
            border-radius: 8px;
            padding: 0.6rem;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: flyToLog 0.8s ease-out forwards;
        }

        .flying-entry .flying-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            margin-bottom: 0.3rem;
            color: var(--charcoal);
        }

        .flying-entry .flying-text {
            font-size: 0.7rem;
            line-height: 1.3;
            color: var(--charcoal);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Scrollbar Styling */
        .log-entries::-webkit-scrollbar,
        .notepad-area::-webkit-scrollbar {
            width: 8px;
        }

        .log-entries::-webkit-scrollbar-track,
        .notepad-area::-webkit-scrollbar-track {
            background: var(--cream);
            border-radius: 4px;
        }

        .log-entries::-webkit-scrollbar-thumb,
        .notepad-area::-webkit-scrollbar-thumb {
            background: var(--teal);
            border-radius: 4px;
        }

        .log-entries::-webkit-scrollbar-thumb:hover,
        .notepad-area::-webkit-scrollbar-thumb:hover {
            background: var(--light-teal);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            /* Narrower sidebar on medium screens */
            .sidebar {
                width: 240px;
            }

            .main-area {
                margin-left: 240px;
            }

            /* Right panel narrower */
            .right-panel {
                width: 320px;
                right: -320px;
            }

            .right-panel-toggle.active {
                right: 320px;
            }
        }

        @media (max-width: 900px) {
            /* Split pane becomes stacked on smaller screens */
            .work-area-content.split-pane {
                flex-wrap: wrap;
            }

            .work-area-content.split-pane .work-area-left,
            .work-area-content.split-pane .work-area-right {
                flex: 1 1 100%;
            }

            /* Dashboard cards stack */
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            /* Quick actions wrap */
            .quick-actions {
                flex-wrap: wrap;
            }
        }

        @media (max-width: 768px) {
            /* Sidebar becomes hidden overlay */
            .sidebar {
                left: -280px;
                width: 280px;
                transition: left 0.3s ease;
            }

            .sidebar.open {
                left: 0;
            }

            .main-area {
                margin-left: 0;
                padding: 1rem;
            }

            .phase-buttons {
                flex-direction: column;
            }

            .phase-btn {
                min-width: 100%;
            }

            .models-grid {
                grid-template-columns: 1fr;
            }

            /* Right panel becomes full-width bottom sheet */
            .right-panel {
                width: 100%;
                height: 70vh;
                top: auto;
                bottom: -70vh;
                right: 0;
                left: 0;
                transition: bottom 0.3s ease;
                border-radius: 16px 16px 0 0;
            }

            .right-panel.open {
                bottom: 0;
            }

            .right-panel-toggle {
                bottom: 0;
                top: auto;
                right: 50%;
                transform: translateX(50%);
                writing-mode: horizontal-tb;
                border-radius: 8px 8px 0 0;
                padding: 0.5rem 1rem;
            }

            .right-panel-toggle.active {
                right: 50%;
                bottom: 70vh;
            }

            /* Modal adjustments */
            .modal {
                width: 95%;
                margin: 1rem;
            }

            /* Action buttons stack on mobile */
            .action-buttons {
                flex-wrap: wrap;
            }

            .action-buttons .btn {
                flex: 1 1 auto;
            }

            /* Hide old toggle buttons */
            .toggle-buttons, .toggle-buttons-left {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.2rem;
            }

            .header p {
                font-size: 0.75rem;
            }

            .quick-action-btn {
                flex: 1 1 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Persistent Left Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-greeting" id="sidebarGreeting">Welcome!</div>
                <div class="sidebar-subgreeting">How can I help you decide?</div>
            </div>

            <nav class="sidebar-nav">
                <!-- Quick Access Section -->
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Quick Access</div>
                    <div class="sidebar-item" id="navHome">
                        <div class="sidebar-item-icon">🏠</div>
                        <div class="sidebar-item-content">
                            <div class="sidebar-item-label">Home</div>
                        </div>
                    </div>
                    <div class="sidebar-item" id="navNotepad">
                        <div class="sidebar-item-icon">📝</div>
                        <div class="sidebar-item-content">
                            <div class="sidebar-item-label">Notepad</div>
                            <div class="sidebar-item-sublabel">Compile your thinking</div>
                        </div>
                    </div>
                    <div class="sidebar-item" id="navLog">
                        <div class="sidebar-item-icon">📋</div>
                        <div class="sidebar-item-content">
                            <div class="sidebar-item-label">Decision Log</div>
                            <div class="sidebar-item-sublabel" id="logCount">0 entries</div>
                        </div>
                    </div>
                </div>

                <!-- Decision Phases Section -->
                <div class="sidebar-section" id="phasesSection">
                    <div class="sidebar-section-title">Decision Phases</div>

                    <div class="phase-sidebar-item" data-phase="diagnostic">
                        <div class="phase-icon diagnostic">1</div>
                        <div class="phase-sidebar-content">
                            <div class="phase-sidebar-label">
                                Diagnose
                                <span class="status-badge not-started" id="statusDiagnostic">Not Started</span>
                            </div>
                            <div class="phase-progress-bar">
                                <div class="phase-progress-fill diagnostic" id="progressDiagnostic" style="width: 0%"></div>
                            </div>
                            <div class="phase-progress-text" id="progressTextDiagnostic">0/6 models</div>
                        </div>
                    </div>

                    <div class="phase-sidebar-item" data-phase="evaluative">
                        <div class="phase-icon evaluative">2</div>
                        <div class="phase-sidebar-content">
                            <div class="phase-sidebar-label">
                                Evaluate
                                <span class="status-badge not-started" id="statusEvaluative">Not Started</span>
                            </div>
                            <div class="phase-progress-bar">
                                <div class="phase-progress-fill evaluative" id="progressEvaluative" style="width: 0%"></div>
                            </div>
                            <div class="phase-progress-text" id="progressTextEvaluative">0/7 models</div>
                        </div>
                    </div>

                    <div class="phase-sidebar-item" data-phase="protective">
                        <div class="phase-icon protective">3</div>
                        <div class="phase-sidebar-content">
                            <div class="phase-sidebar-label">
                                Protect
                                <span class="status-badge not-started" id="statusProtective">Not Started</span>
                            </div>
                            <div class="phase-progress-bar">
                                <div class="phase-progress-fill protective" id="progressProtective" style="width: 0%"></div>
                            </div>
                            <div class="phase-progress-text" id="progressTextProtective">0/7 models</div>
                        </div>
                    </div>

                    <div class="phase-sidebar-item" data-phase="generative">
                        <div class="phase-icon generative">4</div>
                        <div class="phase-sidebar-content">
                            <div class="phase-sidebar-label">
                                Generate
                                <span class="status-badge not-started" id="statusGenerative">Not Started</span>
                            </div>
                            <div class="phase-progress-bar">
                                <div class="phase-progress-fill generative" id="progressGenerative" style="width: 0%"></div>
                            </div>
                            <div class="phase-progress-text" id="progressTextGenerative">0/7 models</div>
                        </div>
                    </div>

                    <div class="phase-sidebar-item" data-phase="implementation">
                        <div class="phase-icon implementation">5</div>
                        <div class="phase-sidebar-content">
                            <div class="phase-sidebar-label">
                                Implement
                                <span class="status-badge not-started" id="statusImplementation">Not Started</span>
                            </div>
                            <div class="phase-progress-bar">
                                <div class="phase-progress-fill implementation" id="progressImplementation" style="width: 0%"></div>
                            </div>
                            <div class="phase-progress-text" id="progressTextImplementation">0/7 models</div>
                        </div>
                    </div>
                </div>
            </nav>

            <div class="sidebar-footer">
                <button class="sidebar-footer-btn" id="startOverSidebar">
                    🔄 Start New Decision
                </button>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="main-area">
            <!-- Quick Actions Bar -->
            <div class="quick-actions" id="quickActions">
                <button class="quick-action-btn primary" id="quickSuggest">
                    💡 Suggest a Model
                </button>
                <button class="quick-action-btn" id="quickProgress">
                    📊 View Progress
                </button>
                <button class="quick-action-btn" id="quickExport">
                    📤 Export Session
                </button>
            </div>

            <!-- Dashboard Overview (shown on home) -->
            <div class="dashboard-grid" id="dashboardGrid">
                <div class="dashboard-card">
                    <div class="dashboard-card-header">
                        <div class="dashboard-card-title">📋 Your Problem</div>
                        <span class="dashboard-card-action" id="editProblem">Edit</span>
                    </div>
                    <div id="dashboardProblem" style="font-size: 0.85rem; color: var(--charcoal); opacity: 0.8;">
                        No problem defined yet. Start by describing your decision or problem.
                    </div>
                </div>

                <div class="dashboard-card">
                    <div class="dashboard-card-header">
                        <div class="dashboard-card-title">📈 Progress Overview</div>
                    </div>
                    <div class="progress-overview" id="progressOverview">
                        <!-- Progress rows will be populated by JS -->
                    </div>
                </div>
            </div>

            <div class="container">
                <!-- Problem Reference Banner - shows after problem is described -->
                <div class="problem-reference" id="problemReference">
                    <div class="problem-reference-header">Your Decision / Problem</div>
                    <div class="problem-reference-text" id="problemReferenceText"></div>
                </div>

                <!-- Problem Type Selector - shows after problem description, before models -->
                <div class="problem-type-selector" id="problemTypeSelector">
                    <h3>What type of problem is this?</h3>
                    <p>Selecting a problem type will show you the most relevant mental models for your situation.</p>
                    <div class="problem-types-grid" id="problemTypesGrid">
                        <!-- Problem types will be populated by JavaScript -->
                    </div>
                    <button class="continue-btn" id="continueBtn">Continue with Selected Type</button>
                </div>

                <!-- Work Area - appears first, at top -->
                <div class="work-area">
                    <h3>Your Response</h3>
                    <div class="work-area-content" id="workAreaContent">
                        <div class="work-area-left">
                            <div class="selected-model-display empty" id="selectedModelDisplay">
                                Select a mental model to begin...
                            </div>
                        </div>
                        <div class="work-area-right">
                            <div class="response-section">
                                <textarea id="responseInput" placeholder="Apply this mental model to your situation..."></textarea>
                                <div class="action-buttons">
                                    <button class="btn btn-primary" id="saveBtn">Add to Log</button>
                                    <button class="btn btn-secondary" id="clearBtn">Clear Answer</button>
                                    <button class="btn btn-warning" id="startOverBtn">Start Over</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Decision Summary Section -->
                <div class="decision-summary" id="decisionSummary">
                    <h3>Decision Summary</h3>
                    <p class="decision-summary-intro">
                        You've applied multiple mental models to your problem. Now synthesize your insights into a clear decision or action plan.
                    </p>
                    <textarea id="summaryInput" placeholder="Based on my analysis, my decision is...

Key insights:
1.
2.
3.

Next steps:
- "></textarea>
                    <div class="decision-summary-actions">
                        <button class="btn btn-summary" id="saveSummaryBtn">Save Summary to Log</button>
                        <button class="btn btn-secondary" id="exportSessionBtn">Export Full Session</button>
                    </div>
                </div>

                <!-- Phase Navigation - hidden initially -->
                <div class="phase-navigation">
                    <h2>Decision-Making Sequence</h2>
                    <div class="phase-buttons">
                        <button class="phase-btn diagnostic active" data-phase="diagnostic">
                            1. Diagnose
                        </button>
                        <button class="phase-btn evaluative" data-phase="evaluative">
                            2. Evaluate
                        </button>
                        <button class="phase-btn protective" data-phase="protective">
                            3. Protect
                        </button>
                        <button class="phase-btn generative" data-phase="generative">
                            4. Generate
                        </button>
                        <button class="phase-btn implementation" data-phase="implementation">
                            5. Implement
                        </button>
                    </div>
                </div>

                <!-- Models Section - hidden initially -->
                <div class="models-section">
                    <div class="phase-description diagnostic" id="phaseDescription">
                        <h3>Diagnostic Models</h3>
                        <p><strong>Purpose:</strong> Understand what's actually happening before making decisions</p>
                        <p class="core-question">What's the true nature of this situation?</p>
                    </div>
                    <div class="models-grid" id="modelsGrid">
                        <!-- Models will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </main>

        <!-- Right Panel Toggle -->
        <button class="right-panel-toggle" id="rightPanelToggle">📋 Log & Notes</button>

        <!-- Right Panel - Combined Log and Notepad -->
        <div class="right-panel" id="rightPanel">
            <div class="panel-header panel-header-right">
                <div class="panel-tabs">
                    <button class="panel-tab active" id="tabLog">Decision Log</button>
                    <button class="panel-tab" id="tabNotepad">Notepad</button>
                </div>
                <button class="panel-close" id="rightPanelClose">&times;</button>
            </div>
            <div class="panel-content">
                <!-- Decision Log Section -->
                <div class="panel-section active" id="logSection">
                    <div class="log-header">
                        <span class="log-header-title">Entries</span>
                        <div class="log-sort-toggle">
                            <span>Sort:</span>
                            <button id="sortNewest" class="active">Newest</button>
                            <button id="sortOldest">Oldest</button>
                        </div>
                    </div>
                    <div class="log-entries" id="logEntries">
                        <div class="empty-state">No entries yet. Start by describing your problem.</div>
                    </div>
                </div>

                <!-- Notepad Section -->
                <div class="panel-section" id="notepadSection">
                    <div class="notepad">
                        <div class="notepad-area empty" id="notepadArea" contenteditable="true">
                            Drag log entries here to compile your thinking...
                        </div>
                        <div class="notepad-actions">
                            <button id="clearNotepad">Clear</button>
                            <button id="copyNotepad">Copy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div class="modal-overlay" id="confirmModal">
            <div class="modal">
                <h3>Start Over?</h3>
                <p>This will clear all your work including your problem description, all log entries, and notepad content. This action cannot be undone.</p>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-cancel" id="modalCancel">Cancel</button>
                    <button class="modal-btn modal-btn-confirm" id="modalConfirm">Yes, Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mental Models Data Structure
        const mentalModelsData = {
            diagnostic: {
                title: "Diagnostic Models",
                purpose: "Understand what's actually happening before making decisions",
                coreQuestion: "What's the true nature of this situation?",
                whenToUse: "At the beginning of any decision process, when confused or stuck, when conventional explanations don't fit the evidence.",
                models: [
                    {
                        name: "Circle of Competence",
                        description: "Know what you know vs. what you assume",
                        explanation: "The Circle of Competence, popularized by Warren Buffett and Charlie Munger, helps you identify the boundaries of your true knowledge. Inside your circle are areas where you have genuine expertise through study, experience, or training. Outside are areas where you may have opinions but lack deep understanding. The key insight is that the size of your circle matters less than knowing its boundaries.",
                        example: "A successful software engineer is asked to evaluate a commercial real estate investment. Despite being intelligent and analytical, real estate requires understanding of local markets, zoning laws, property management, and financing structures they've never studied. Their technical success doesn't transfer. Recognizing this, they either decline, find an expert partner, or invest significant time learning before deciding.",
                        prompts: [
                            "What specific expertise or experience do you have that's directly relevant to this situation?",
                            "Where are you relying on assumptions, analogies, or 'common sense' rather than verified knowledge?",
                            "If you had to teach someone the fundamentals of this domain, could you? What gaps would appear?",
                            "Who has genuine expertise here that you could consult or defer to?"
                        ],
                        warnings: [
                            "Confidence is not competence—feeling certain doesn't mean you're right",
                            "Success in one domain doesn't automatically transfer to another",
                            "The Dunning-Kruger effect: those with limited knowledge often overestimate their competence"
                        ],
                        relatedModels: ["First Principles", "Confirmation Bias Recognition"]
                    },
                    {
                        name: "Occam's Razor",
                        description: "The simplest explanation is usually correct",
                        explanation: "Occam's Razor (also called the principle of parsimony) states that when you have competing explanations for something, the one with the fewest assumptions is usually correct. This doesn't mean the simplest explanation is always right, but that you shouldn't add complexity without evidence. Each additional assumption multiplies the chances of error.",
                        example: "Your laptop won't turn on. You could theorize: (A) the battery is dead, or (B) a power surge damaged the motherboard, which triggered a firmware corruption, which disabled the power button circuit. Occam's Razor says try charging the battery first. Don't assume a complex chain of failures when a simple explanation fits.",
                        prompts: [
                            "What is the simplest explanation that accounts for all the evidence you're seeing?",
                            "How many assumptions does your current theory require? Can you list them?",
                            "Are you adding complexity because of evidence, or because of anxiety, ego, or narrative appeal?",
                            "What would you need to see to rule out the simpler explanation?"
                        ],
                        warnings: [
                            "Simple doesn't mean easy or obvious—it means fewer moving parts",
                            "Don't oversimplify: the explanation must still fit all the evidence",
                            "Sometimes reality is genuinely complex; Occam's Razor is a starting point, not a conclusion"
                        ],
                        relatedModels: ["First Principles", "Root Cause Analysis"]
                    },
                    {
                        name: "First Principles",
                        description: "Break down to fundamental truths",
                        explanation: "First Principles thinking means breaking down a problem into its most basic, foundational truths—things you know to be true independent of convention, assumption, or analogy—and then building up from there. Instead of reasoning by analogy ('this is how it's always been done'), you ask 'what do we know for certain?' This approach, used by scientists and innovators from Aristotle to Elon Musk, often reveals that conventional limits are actually just conventions.",
                        example: "When SpaceX started, rockets cost $65 million. Instead of accepting this, Musk asked: what are rockets made of? Aluminum, titanium, copper, carbon fiber. What do those materials cost on the commodity market? About 2% of the rocket price. The rest was inefficiency, tradition, and markup. By building from first principles rather than industry convention, SpaceX cut costs by 90%.",
                        prompts: [
                            "What are the fundamental truths or facts in this situation that you know to be true?",
                            "What assumptions are you inheriting from convention, tradition, or 'how things are done'?",
                            "If you had to explain this problem to someone with no context, what are the irreducible components?",
                            "What would you do differently if you were starting from scratch with no constraints?"
                        ],
                        warnings: [
                            "First principles thinking is mentally taxing—don't use it for every minor decision",
                            "Be careful not to dismiss useful conventions just because they're conventional",
                            "You still need domain knowledge to identify what the true fundamentals are"
                        ],
                        relatedModels: ["Circle of Competence", "Root Cause Analysis", "Systems Thinking"]
                    },
                    {
                        name: "Confirmation Bias Recognition",
                        description: "Challenge your assumptions",
                        explanation: "Confirmation bias is our tendency to search for, interpret, favor, and recall information in a way that confirms our existing beliefs. We literally see what we expect to see. This isn't a character flaw—it's how human cognition works. The only defense is actively seeking disconfirmation: looking for evidence that proves you wrong, not right. Scientists call this 'falsification' and it's the foundation of the scientific method.",
                        example: "A manager believes a team member is unmotivated. They start noticing every time the person arrives late or seems disengaged, while overlooking the quality work produced and the personal challenges the person may be facing. Each observation 'confirms' their belief. To counter this, they should actively look for evidence of motivation: projects completed, problems solved, ideas contributed.",
                        prompts: [
                            "What do you believe about this situation? State it clearly as a hypothesis.",
                            "What evidence would prove your belief WRONG? Have you looked for it?",
                            "Who disagrees with your view? What's the strongest version of their argument?",
                            "If you woke up tomorrow and discovered you were completely wrong about this, what would be the first clue?"
                        ],
                        warnings: [
                            "Seeking disconfirming evidence feels uncomfortable—that discomfort is a feature, not a bug",
                            "You can't eliminate confirmation bias, only manage it through deliberate practice",
                            "Being aware of the bias doesn't automatically protect you from it"
                        ],
                        relatedModels: ["Circle of Competence", "First Principles", "Inversion"]
                    },
                    {
                        name: "Root Cause Analysis",
                        description: "Find underlying causes, not symptoms",
                        explanation: "Root Cause Analysis is a systematic process of identifying the fundamental reason why a problem occurred, rather than just addressing surface symptoms. The most common technique is '5 Whys'—asking 'why' repeatedly until you reach a cause that, if addressed, would prevent recurrence. Treating symptoms provides temporary relief; treating root causes provides lasting solutions.",
                        example: "A website keeps crashing. Symptom: server runs out of memory. Why? Too many database connections. Why? Connections aren't being closed properly. Why? Developers aren't following the connection pooling standard. Why? The standard isn't documented or enforced. Why? No code review process exists. Root cause: missing development process, not a technical bug. Fix the process, fix the problem permanently.",
                        prompts: [
                            "What is the immediate problem? Now ask: WHY is this happening?",
                            "Take your answer and ask WHY again. Repeat at least 5 times.",
                            "At what level of 'why' do you find something you can actually change or control?",
                            "If you fixed this root cause, would the original problem be impossible or unlikely to recur?"
                        ],
                        warnings: [
                            "Don't stop at the first 'why'—surface causes are rarely root causes",
                            "There may be multiple root causes; don't assume there's only one",
                            "Sometimes you need to treat symptoms urgently while working on root causes in parallel"
                        ],
                        relatedModels: ["First Principles", "Systems Thinking", "Occam's Razor"]
                    },
                    {
                        name: "Systems Thinking",
                        description: "See how parts interact",
                        explanation: "Systems Thinking is a holistic approach that focuses on how components interrelate and work together over time within larger systems. Instead of analyzing parts in isolation, you examine feedback loops, delays, unintended consequences, and emergent behaviors. Many problems persist because solutions address components without understanding the system dynamics that created and maintain the problem.",
                        example: "A city tries to reduce traffic by adding highway lanes. Initially traffic improves, but within two years it's worse than before. Why? The system responded: easier commutes attracted more drivers, developers built more suburbs, and the induced demand filled the new capacity. A systems view would have predicted this and suggested alternatives like congestion pricing or transit investment that change the feedback loops.",
                        prompts: [
                            "What are all the components or stakeholders in this system? How are they connected?",
                            "What feedback loops exist? Are they reinforcing (amplifying) or balancing (stabilizing)?",
                            "What are the delays in this system? How long before actions produce effects?",
                            "If you made your proposed change, what secondary effects might ripple through the system?"
                        ],
                        warnings: [
                            "Systems are often counter-intuitive: obvious solutions can backfire",
                            "Delays between action and effect make it hard to learn from feedback",
                            "You can't understand a system just by understanding its parts—emergence is real"
                        ],
                        relatedModels: ["Second-Order Thinking", "Root Cause Analysis", "First Principles"]
                    }
                ]
            },
            evaluative: {
                title: "Evaluative Models",
                purpose: "Weigh options and determine what matters most",
                coreQuestion: "How do these alternatives compare?",
                whenToUse: "When comparing alternatives, allocating resources, prioritizing actions, or determining trade-offs.",
                models: [
                    {
                        name: "Opportunity Cost",
                        description: "What you give up for this choice",
                        explanation: "Opportunity cost is the value of the next-best alternative you give up when making a choice. Every decision has a cost beyond the obvious price tag—the cost of what you could have done instead. This concept, fundamental to economics, reminds us that resources (time, money, attention) spent on one thing cannot be spent on another. The true cost of anything is what you sacrifice to get it.",
                        example: "You're deciding whether to spend $50,000 on an MBA. The obvious cost is tuition. But the opportunity cost includes: 2 years of salary you won't earn (~$150,000), work experience you won't gain, relationships you won't build at work, and other ways you could invest that $50,000. The real question isn't 'Is an MBA worth $50,000?' but 'Is an MBA worth $200,000+ and two years of your life compared to the alternatives?'",
                        prompts: [
                            "If you choose this option, what specifically are you giving up? List the top 3 alternatives.",
                            "What could you do with the same time, money, or resources instead?",
                            "What's the best alternative use of this resource? How does it compare?",
                            "Are you accounting for hidden costs like time, energy, and attention—not just money?"
                        ],
                        warnings: [
                            "Sunk costs are NOT opportunity costs—don't factor in what you've already spent",
                            "Opportunity cost includes intangibles like learning, relationships, and optionality",
                            "The comparison should be to your best alternative, not just any alternative"
                        ],
                        relatedModels: ["Cost-Benefit Analysis", "Satisficing vs. Optimizing", "Pareto Principle (80/20)"]
                    },
                    {
                        name: "Incentives",
                        description: "What drives the behavior",
                        explanation: "Incentives are the rewards and punishments that motivate behavior. Charlie Munger famously said, 'Show me the incentive and I will show you the outcome.' People respond predictably to incentives—often in ways that weren't intended. Understanding incentives helps you predict behavior, design better systems, and avoid being manipulated. When behavior seems irrational, you probably don't understand the incentives.",
                        example: "Wells Fargo created incentives for employees to open new accounts, with bonuses tied to account numbers. The intended outcome: more customer engagement. The actual outcome: employees opened millions of fake accounts without customer consent. The incentive rewarded the metric (account numbers) rather than the goal (customer value). Understanding this would have predicted the scandal.",
                        prompts: [
                            "What are the explicit incentives in this situation? Who gets rewarded for what?",
                            "What are the hidden or implicit incentives? What behavior does the system actually reward?",
                            "If you follow the incentives to their logical conclusion, what behavior would you predict?",
                            "Are the incentives aligned with the actual goals? Where might they diverge?"
                        ],
                        warnings: [
                            "People optimize for what's measured, not necessarily what matters",
                            "Incentives you didn't design still exist—look for them",
                            "Short-term incentives often conflict with long-term goals"
                        ],
                        relatedModels: ["Second-Order Thinking", "Systems Thinking", "Confirmation Bias Recognition"]
                    },
                    {
                        name: "Second-Order Thinking",
                        description: "Consider downstream consequences",
                        explanation: "Second-order thinking means considering the consequences of the consequences. First-order thinking asks 'What happens if I do X?' Second-order thinking asks 'And then what?' Most people stop at first-order effects, which is why second-order thinkers have a significant advantage. The immediate effect of a decision is often obvious; the downstream effects are where surprises—and opportunities—live.",
                        example: "First-order thinking: 'If we cut prices, we'll sell more units.' Second-order thinking: 'If we cut prices, we'll sell more units. Then competitors will cut prices too. Then margins shrink industry-wide. Then we need to cut costs. Then quality suffers. Then customers leave.' The first-order effect (more sales) was positive; the second and third-order effects were devastating.",
                        prompts: [
                            "What's the immediate, obvious effect of this decision? (First-order)",
                            "Then what happens? What do others do in response? (Second-order)",
                            "And then what? Follow the chain at least 3 steps. (Third-order and beyond)",
                            "Who else is affected, and how will they respond? What feedback loops exist?"
                        ],
                        warnings: [
                            "Second-order effects often oppose first-order effects",
                            "The further out you project, the more uncertain—but still valuable to consider",
                            "Others' responses to your actions create most second-order effects"
                        ],
                        relatedModels: ["Systems Thinking", "Incentives", "Pre-mortem"]
                    },
                    {
                        name: "Cost-Benefit Analysis",
                        description: "Does the gain justify the cost",
                        explanation: "Cost-benefit analysis is a systematic approach to weighing the total expected costs against the total expected benefits of a decision. While it sounds simple, the challenge is identifying ALL costs and benefits—including indirect, delayed, and intangible ones. A rigorous cost-benefit analysis forces you to quantify your assumptions and reveals hidden trade-offs.",
                        example: "A company considers implementing a four-day work week. Obvious costs: 20% less work time. Hidden costs: coordination challenges, customer coverage gaps, potential resentment from those who can't participate. Obvious benefits: employee satisfaction, recruitment advantage. Hidden benefits: forced prioritization, reduced burnout, lower turnover costs, increased productivity per hour. Only by listing all factors can you make an informed decision.",
                        prompts: [
                            "List ALL costs: direct, indirect, immediate, delayed, tangible, and intangible.",
                            "List ALL benefits: direct, indirect, immediate, delayed, tangible, and intangible.",
                            "Can you quantify these? Even rough estimates force clearer thinking.",
                            "What costs or benefits might you be missing? What would a critic add to your list?"
                        ],
                        warnings: [
                            "Intangible costs/benefits are real even if hard to quantify—don't ignore them",
                            "Be wary of motivated reasoning—are you inflating benefits and minimizing costs?",
                            "Consider who bears the costs vs. who receives the benefits"
                        ],
                        relatedModels: ["Opportunity Cost", "Expected Value", "Second-Order Thinking"]
                    },
                    {
                        name: "Expected Value",
                        description: "Probability-weighted outcomes",
                        explanation: "Expected value (EV) is a decision-making framework that accounts for both the magnitude of outcomes and their probability. You calculate it by multiplying each possible outcome by its probability and summing the results. EV helps you make decisions under uncertainty by focusing on long-term average outcomes rather than individual results. A positive expected value decision may lose sometimes, but wins on average.",
                        example: "You're offered a bet: flip a coin, heads you win $200, tails you lose $100. Should you take it? EV = (50% × $200) + (50% × -$100) = $100 - $50 = $50. The expected value is +$50, so mathematically you should take this bet every time. Even though you'll lose half the time, over many decisions like this, you'll come out ahead.",
                        prompts: [
                            "What are all the possible outcomes of this decision? List them.",
                            "What's your estimated probability for each outcome? (They should sum to 100%)",
                            "What's the value (positive or negative) of each outcome?",
                            "Calculate: For each outcome, multiply probability × value, then sum all results."
                        ],
                        warnings: [
                            "Garbage in, garbage out—your EV is only as good as your probability estimates",
                            "EV assumes you can play multiple times; one-shot decisions may need different thinking",
                            "EV doesn't account for risk tolerance or ruin—don't bet your entire bankroll on positive EV"
                        ],
                        relatedModels: ["Cost-Benefit Analysis", "Margin of Safety", "Reversible vs. Irreversible Decisions"]
                    },
                    {
                        name: "Pareto Principle (80/20)",
                        description: "Find disproportionate impact",
                        explanation: "The Pareto Principle observes that roughly 80% of effects come from 20% of causes. This pattern appears everywhere: 80% of sales from 20% of customers, 80% of bugs from 20% of code, 80% of results from 20% of effort. The exact ratio varies, but the insight is universal: inputs and outputs are not evenly distributed. Finding and focusing on the vital few rather than the trivial many is the key to efficiency.",
                        example: "A software company analyzes customer support tickets and finds that 80% of complaints come from 3 features (out of 50). Instead of spreading improvement efforts across all features equally, they focus intensely on those 3. Six months later, support tickets dropped 60% with only 6% of features improved. The same principle: a small number of causes drive most of the problems.",
                        prompts: [
                            "In this situation, what 20% of inputs might be driving 80% of the results?",
                            "What are the few vital factors vs. the many trivial ones?",
                            "If you could only work on one thing, which would have the most disproportionate impact?",
                            "What are you spending time on that contributes little to outcomes?"
                        ],
                        warnings: [
                            "80/20 is a guideline, not a law—the actual ratio varies",
                            "The vital 20% changes over time; reassess regularly",
                            "Don't neglect the 'trivial many' entirely—some provide necessary foundation"
                        ],
                        relatedModels: ["Leverage", "80/20 Action", "Opportunity Cost"]
                    },
                    {
                        name: "Satisficing vs. Optimizing",
                        description: "Good enough vs. perfect",
                        explanation: "Satisficing means choosing an option that meets your criteria, even if better options might exist. Optimizing means searching until you find the best possible option. Economist Herbert Simon introduced satisficing, recognizing that optimization has costs: time, energy, and decision fatigue. Often, the search for 'perfect' costs more than the improvement it yields. Knowing when to satisfice and when to optimize is itself an optimization.",
                        example: "Buying a house: An optimizer visits 50 houses over 6 months, running spreadsheets on each, only to find their top choice sold while they were analyzing. A satisficer defines criteria (3 bedrooms, good schools, under budget), views houses until one meets all criteria, and buys it. The satisficer may not get the 'best' house, but avoids analysis paralysis and opportunity cost of endless searching.",
                        prompts: [
                            "What criteria would make an option 'good enough' for this decision?",
                            "What's the cost of continued searching? Time, stress, missed opportunities?",
                            "Is this a reversible decision where satisficing is low-risk, or irreversible where optimizing pays off?",
                            "Are you optimizing because it matters, or because you're avoiding the discomfort of deciding?"
                        ],
                        warnings: [
                            "Satisficing isn't settling—it's strategic acceptance that perfect is costly",
                            "High-stakes, irreversible decisions may warrant more optimization",
                            "The best decision made today often beats a perfect decision made too late"
                        ],
                        relatedModels: ["Opportunity Cost", "Reversible vs. Irreversible Decisions", "Pareto Principle (80/20)"]
                    }
                ]
            },
            protective: {
                title: "Protective Models",
                purpose: "Reduce risk and avoid disaster",
                coreQuestion: "How do I prevent failure?",
                whenToUse: "Before major commitments, when downside is severe, in high-uncertainty situations, when building systems or strategies.",
                models: [
                    {
                        name: "Margin of Safety",
                        description: "Build in extra buffer capacity",
                        explanation: "Margin of safety means building in a buffer between what you need and what you have. Engineers design bridges to hold 10x their expected load. Value investors buy stocks at significant discounts to their calculated worth. The margin accounts for errors in your estimates, unexpected events, and the fundamental uncertainty of the future. The greater the stakes and uncertainty, the larger the margin should be.",
                        example: "You're planning a product launch with a deadline of March 1st. Your best estimate says you'll finish February 15th. Without margin of safety, you commit to March 1st. With margin of safety, you recognize that estimates are often wrong—unexpected bugs, sick team members, scope changes. You either commit to March 15th (giving yourself buffer) or work backward from March 1st and plan to finish January 15th internally.",
                        prompts: [
                            "What's the minimum you need for this to work? Now, what buffer should you add?",
                            "What could go wrong that would consume your margin? Is your buffer large enough?",
                            "Where are you cutting it too close? What happens if your estimates are 50% off?",
                            "How severe would failure be? (Higher stakes = larger margin needed)"
                        ],
                        warnings: [
                            "Too much margin can be wasteful or cause you to miss opportunities",
                            "Margin of safety is not a substitute for good planning—it's insurance against uncertainty",
                            "The margin should scale with the stakes and your uncertainty level"
                        ],
                        relatedModels: ["Expected Value", "Pre-mortem", "Redundancy"]
                    },
                    {
                        name: "Inversion",
                        description: "Ask how to fail, then avoid that",
                        explanation: "Inversion means approaching a problem backward. Instead of asking 'How do I achieve success?' ask 'How do I guarantee failure?' Then avoid those things. Carl Jacobi, the mathematician, said 'Invert, always invert.' Many problems are easier to solve in reverse. Avoiding stupidity is often easier than seeking brilliance. If you avoid all the ways to fail, what remains is more likely to succeed.",
                        example: "Instead of asking 'How do I build a great company?' ask 'How do I guarantee my company fails?' Answers: ignore customers, hire poorly, run out of cash, move slowly, have no clear strategy, let politics dominate. Now you have a clear list of things to avoid. Success isn't guaranteed, but failure becomes less likely.",
                        prompts: [
                            "What would guarantee failure in this situation? List at least 5 ways.",
                            "Which of these failure modes are you currently at risk of?",
                            "What's the opposite of success here? How do you avoid that?",
                            "If a competitor wanted to sabotage this, what would they do?"
                        ],
                        warnings: [
                            "Inversion reveals what to avoid, but doesn't automatically tell you what to do",
                            "Some failure modes are more likely than others—prioritize avoiding the probable ones",
                            "Don't become so focused on avoiding failure that you become paralyzed"
                        ],
                        relatedModels: ["Pre-mortem", "Confirmation Bias Recognition", "First Principles"]
                    },
                    {
                        name: "Reversible vs. Irreversible Decisions",
                        description: "Can you undo this decision",
                        explanation: "Jeff Bezos distinguishes between Type 1 decisions (irreversible, high-stakes—walk through a one-way door) and Type 2 decisions (reversible, lower-stakes—walk through a two-way door you can return through). Type 1 decisions warrant extensive analysis and caution. Type 2 decisions should be made quickly by individuals or small groups. Most decisions are Type 2, but we often treat them as Type 1, causing slowness and missed opportunities.",
                        example: "Hiring a senior executive is Type 1—hard to undo, high impact, warrants extensive vetting. Choosing which A/B test to run is Type 2—easily reversible, limited downside, should be decided quickly. Many organizations agonize over Type 2 decisions as if they were Type 1, creating bureaucracy and slowness. Recognize the difference and match your decision-making process to the decision type.",
                        prompts: [
                            "If this decision turns out to be wrong, can you reverse it? At what cost?",
                            "Is this a one-way door (Type 1) or a two-way door (Type 2)?",
                            "Are you treating a reversible decision with irreversible-level caution? Why?",
                            "What would make this decision more reversible? Can you structure it that way?"
                        ],
                        warnings: [
                            "Some decisions look reversible but have hidden switching costs",
                            "Time itself is irreversible—a reversible decision delayed is opportunity lost",
                            "Don't use 'it's reversible' as an excuse to avoid thinking"
                        ],
                        relatedModels: ["Satisficing vs. Optimizing", "Minimum Viable Product (MVP)", "Margin of Safety"]
                    },
                    {
                        name: "Pre-mortem",
                        description: "Identify failure modes in advance",
                        explanation: "A pre-mortem is a thought experiment: imagine your project has failed spectacularly, then work backward to identify what caused the failure. Unlike a post-mortem (which analyzes actual failure after the fact), a pre-mortem harnesses hindsight bias proactively. Research by Gary Klein shows that pre-mortems increase the ability to identify reasons for future outcomes by 30%. It's easier to generate reasons for a known outcome than to predict an unknown one.",
                        example: "Before launching a new product, gather your team and say: 'It's one year from now. The product launch was a disaster. What happened?' Team members write down reasons independently, then share. Common answers: 'We underestimated competitor response,' 'Key engineer quit mid-project,' 'Customer needs changed,' 'We missed a critical bug.' Now you have a risk register and can address these proactively.",
                        prompts: [
                            "Imagine this has failed completely. What went wrong? Generate at least 5 reasons.",
                            "Which of these failure modes are most likely? Most severe?",
                            "What can you do NOW to prevent or mitigate these failure modes?",
                            "What early warning signs would indicate you're heading toward failure?"
                        ],
                        warnings: [
                            "Pre-mortems reveal risks but don't eliminate them—you must act on the insights",
                            "Don't let the exercise create excessive pessimism or paralysis",
                            "Revisit your pre-mortem periodically as conditions change"
                        ],
                        relatedModels: ["Inversion", "Margin of Safety", "Second-Order Thinking"]
                    },
                    {
                        name: "Antifragility",
                        description: "Benefit from volatility",
                        explanation: "Antifragility, coined by Nassim Taleb, describes things that gain from disorder, stress, and volatility. Fragile things break under stress (a glass). Robust things resist stress (a rock). Antifragile things get stronger from stress (muscles, immune systems, some businesses). In an uncertain world, being antifragile is better than being robust. Instead of just protecting against volatility, position yourself to benefit from it.",
                        example: "A restaurant with one location is fragile—a local recession destroys it. A franchise system is robust—problems in one location don't kill the business. A restaurant consulting business is antifragile—during recessions, struggling restaurants need more help, increasing demand. The consultant benefits from the same volatility that harms individual restaurants.",
                        prompts: [
                            "Is this fragile (harmed by stress), robust (unaffected), or antifragile (benefits from stress)?",
                            "How could you restructure to benefit from volatility rather than just survive it?",
                            "What stressors or challenges could actually make this stronger?",
                            "Where are you exposed to fragility? How can you reduce that exposure?"
                        ],
                        warnings: [
                            "Antifragility often requires accepting small losses to gain from big volatility",
                            "Not everything can or should be antifragile—sometimes robust is the right goal",
                            "Building antifragility takes time; fragile systems fail before they adapt"
                        ],
                        relatedModels: ["Margin of Safety", "Redundancy", "Optionality"]
                    },
                    {
                        name: "Redundancy",
                        description: "Prevent single points of failure",
                        explanation: "Redundancy means having backup systems, people, or resources that can take over if the primary fails. Single points of failure—where one component's failure brings down the whole system—are dangerous. Engineers build redundancy into critical systems: backup generators, RAID storage, multiple data centers. The cost of redundancy is usually far less than the cost of total failure.",
                        example: "A startup's CTO is the only person who understands the core codebase. If they get sick, quit, or get hit by a bus, the company is paralyzed. This is a single point of failure. Solutions: documentation, cross-training other engineers, pair programming, code reviews. The 'bus factor' asks: how many people would need to be hit by a bus before the project fails? You want that number to be high.",
                        prompts: [
                            "What are the single points of failure in this situation? (People, systems, resources)",
                            "If [critical component] failed, what would happen? How would you recover?",
                            "What's the cost of adding redundancy vs. the cost of failure?",
                            "What's your 'bus factor'? What happens if key people become unavailable?"
                        ],
                        warnings: [
                            "Redundancy costs money, time, and complexity—don't over-engineer",
                            "Redundant systems need testing; unused backups may not work when needed",
                            "Perfect redundancy is impossible; prioritize the most critical failure points"
                        ],
                        relatedModels: ["Margin of Safety", "Antifragility", "Critical Path"]
                    },
                    {
                        name: "Precautionary Principle",
                        description: "When unknown risks are too great",
                        explanation: "The Precautionary Principle states that when an action raises threats of harm that are uncertain but potentially catastrophic, precautionary measures should be taken even without full scientific certainty. It's asymmetric risk management: when the downside is unbounded or irreversible, the burden of proof should be on those claiming safety, not those claiming danger. This applies when you don't know what you don't know.",
                        example: "A pharmaceutical company has a drug that shows promising early results. Long-term effects are unknown. The precautionary principle suggests: don't rush to market based on short-term data when the downside (unforeseen side effects affecting millions) could be catastrophic and irreversible. The potential benefit of being first must be weighed against the potential harm of being wrong.",
                        prompts: [
                            "What's the worst-case scenario? Is it catastrophic or irreversible?",
                            "How well do you understand the risks? What are the known unknowns and unknown unknowns?",
                            "Who bears the burden of proof—those claiming safety or those claiming danger?",
                            "Is the potential upside worth the potential (even if uncertain) catastrophic downside?"
                        ],
                        warnings: [
                            "Over-application leads to paralysis; not every risk warrants extreme caution",
                            "The precautionary principle itself has costs—delayed benefits, missed opportunities",
                            "Use for potentially catastrophic/irreversible outcomes, not routine decisions"
                        ],
                        relatedModels: ["Margin of Safety", "Reversible vs. Irreversible Decisions", "Expected Value"]
                    }
                ]
            },
            generative: {
                title: "Generative Models",
                purpose: "Create new possibilities and novel solutions",
                coreQuestion: "What options haven't I considered?",
                whenToUse: "When stuck with unsatisfactory options, when innovation is needed, when breaking into new markets or categories.",
                models: [
                    {
                        name: "First Principles (Generative)",
                        description: "Rebuild from scratch differently",
                        explanation: "First Principles thinking in its generative form asks: if we were starting from scratch with no legacy constraints, how would we build this? It's the creative counterpart to diagnostic First Principles. While the diagnostic version breaks down what exists, the generative version reimagines what could be. This is how breakthroughs happen—by refusing to accept inherited constraints that may no longer apply.",
                        example: "Traditional car companies asked: 'How do we make better gas stations?' Tesla asked: 'If we were starting from scratch, would we build gas stations at all?' The answer was home charging and superchargers strategically placed. They didn't improve the existing solution; they rebuilt the problem from first principles. The result was a fundamentally different (and better) fueling infrastructure.",
                        prompts: [
                            "If you were starting completely from scratch today, how would you design this?",
                            "What legacy constraints are you accepting that a new entrant wouldn't have?",
                            "What would a solution look like if you ignored 'how it's always been done'?",
                            "If this industry/problem didn't exist, and you were inventing it today, what would you build?"
                        ],
                        warnings: [
                            "Existing solutions often have good reasons—understand before discarding",
                            "From-scratch thinking ignores switching costs and adoption challenges",
                            "Revolutionary ideas need evolutionary implementation plans"
                        ],
                        relatedModels: ["First Principles", "Constraint Removal", "Reframing"]
                    },
                    {
                        name: "Lateral Thinking",
                        description: "Approach from different angle",
                        explanation: "Lateral thinking, coined by Edward de Bono, means approaching problems indirectly and creatively rather than through traditional step-by-step logic. While vertical thinking digs deeper in the same hole, lateral thinking digs a new hole in a different location. It involves deliberately moving sideways from the expected path to discover new approaches that wouldn't emerge from linear analysis.",
                        example: "A hospital struggled with slow elevators and patient complaints. The obvious solution: faster elevators (expensive, disruptive). The lateral solution: install mirrors on each floor. Patients stopped complaining—not because elevators were faster, but because they were distracted checking their appearance. The actual problem wasn't elevator speed; it was perceived wait time.",
                        prompts: [
                            "What if you approached this from a completely different direction?",
                            "What's an indirect path to the same goal? What would a non-expert try?",
                            "What assumptions are you making about HOW this must be solved?",
                            "What would you do if the obvious approach were impossible?"
                        ],
                        warnings: [
                            "Lateral thinking complements, not replaces, logical analysis",
                            "Not every problem needs a creative solution—sometimes the obvious answer is correct",
                            "Novelty isn't inherently valuable; the lateral solution must actually work"
                        ],
                        relatedModels: ["Reframing", "Constraint Removal", "Analogical Thinking"]
                    },
                    {
                        name: "Combinatorial Thinking",
                        description: "Merge X and Y for new combinations",
                        explanation: "Combinatorial thinking creates new ideas by combining existing elements in novel ways. Most innovations aren't created from nothing—they're new combinations of existing ideas, technologies, or concepts. The iPhone combined a phone, music player, and internet device. Uber combined GPS, smartphones, and ride services. The power comes from seeing connections others miss.",
                        example: "Netflix started as a combination: DVD rental (existing) + mail delivery (existing) + no late fees (existing concept, new application). Later, they combined streaming technology + original content production + data-driven recommendations. Each evolution was a new combination of existing elements. What existing elements in your domain could be combined differently?",
                        prompts: [
                            "What two existing things could you combine to create something new?",
                            "What works well in adjacent industries that you could adapt?",
                            "If you merged your solution with [random other concept], what would result?",
                            "What are the individual components here? What happens if you recombine them?"
                        ],
                        warnings: [
                            "Not all combinations are valuable—the combination must solve a real need",
                            "Combination complexity can create integration challenges",
                            "The best combinations often seem obvious in retrospect"
                        ],
                        relatedModels: ["Analogical Thinking", "First Principles (Generative)", "Blue Ocean Strategy"]
                    },
                    {
                        name: "Constraint Removal",
                        description: "Challenge assumed limitations",
                        explanation: "Constraint removal asks: what if a perceived limitation didn't exist? Many constraints we accept are assumptions, not laws of physics. By systematically questioning each constraint, we often discover that limits are self-imposed or outdated. Even constraints that can't be removed can often be worked around once you see them clearly. The first step to removing a constraint is recognizing you've accepted one.",
                        example: "For decades, the assumption was 'people won't pay for bottled water—it's free from the tap.' This constraint was an assumption, not a fact. By questioning it, entrepreneurs created a multi-billion dollar industry. The constraint 'people won't pay for X' is almost always worth challenging. What constraints are you accepting that might not be real?",
                        prompts: [
                            "What constraints are you assuming? List them all—budget, time, resources, rules, physics.",
                            "For each constraint: Is this truly fixed, or is it an assumption?",
                            "What would you do if [constraint X] didn't exist?",
                            "Which constraint, if removed, would change everything? Can you challenge it?"
                        ],
                        warnings: [
                            "Some constraints are real and important—don't ignore physics or ethics",
                            "Removing constraints often shifts problems rather than solving them",
                            "Social and organizational constraints may be harder to change than technical ones"
                        ],
                        relatedModels: ["First Principles (Generative)", "Reframing", "Lateral Thinking"]
                    },
                    {
                        name: "Analogical Thinking",
                        description: "Learn from different domains",
                        explanation: "Analogical thinking transfers solutions from one domain to another. Many breakthroughs come from asking 'How did they solve a similar problem in a completely different field?' Resistance to this is common—'our industry is different'—but the underlying patterns often transfer. The key is finding the right level of abstraction where the analogy holds.",
                        example: "The designers of the Shinkansen bullet train faced a problem: sonic booms when exiting tunnels. An engineer who was also a birdwatcher noticed kingfishers dive into water without a splash. The kingfisher's beak shape was adapted for the train's nose, solving the sonic boom problem and improving efficiency by 15%. A solution from ornithology applied to engineering.",
                        prompts: [
                            "What's a similar problem that's been solved in a completely different field?",
                            "How would [different industry/discipline] approach this problem?",
                            "What's the abstract structure of this problem? Where else does that structure appear?",
                            "If a biologist/engineer/artist/economist looked at this, what would they see?"
                        ],
                        warnings: [
                            "Analogies can mislead—not all similarities are relevant",
                            "The analogy may transfer the solution but not the implementation details",
                            "'Our industry is different' is often wrong, but sometimes right"
                        ],
                        relatedModels: ["Combinatorial Thinking", "Lateral Thinking", "Reframing"]
                    },
                    {
                        name: "Reframing",
                        description: "Define the problem differently",
                        explanation: "Reframing changes how you define the problem itself. A different frame leads to different solutions. Most problem-solving assumes the problem is correctly defined, but often the definition is the problem. Einstein allegedly said, 'If I had an hour to solve a problem, I'd spend 55 minutes defining the problem and 5 minutes solving it.' The way you frame a problem determines which solutions are visible.",
                        example: "A dog food company struggled to increase market share. Original frame: 'How do we make dog food that dogs like more?' Reframe: 'How do we make dog food that dog OWNERS feel good about buying?' The problem wasn't canine preference—dogs will eat almost anything. The problem was owner guilt and identity. The reframe led to premium, 'healthy' dog food with human-grade ingredients.",
                        prompts: [
                            "How are you currently defining this problem? Write it down explicitly.",
                            "What are three other ways you could define the same situation?",
                            "Who else has a stake in this? How would they frame the problem?",
                            "What if the problem is actually [different than you assumed]?"
                        ],
                        warnings: [
                            "Reframing can be used to avoid hard truths—make sure the new frame is honest",
                            "Some problems are correctly framed; reframing isn't always necessary",
                            "Multiple frames can coexist; you don't have to choose just one"
                        ],
                        relatedModels: ["First Principles", "Lateral Thinking", "Constraint Removal"]
                    },
                    {
                        name: "Blue Ocean Strategy",
                        description: "Find uncontested market space",
                        explanation: "Blue Ocean Strategy, from the book by Kim and Mauborgne, contrasts 'red oceans' (existing markets with fierce competition, bloody with rivalry) with 'blue oceans' (new market spaces where competition is irrelevant). Instead of fighting over existing demand, blue ocean thinking creates new demand. It asks: how do we make the competition irrelevant by creating a new value proposition?",
                        example: "Cirque du Soleil didn't try to out-compete Ringling Brothers for circus customers. They created a blue ocean by combining circus arts with theater, targeting adults willing to pay premium prices for sophisticated entertainment. They eliminated costly elements (animals, star performers, multiple show arenas) and added new ones (artistic themes, refined environment, multiple productions). They didn't win the circus industry; they made it irrelevant.",
                        prompts: [
                            "What industry factors could you eliminate that the industry takes for granted?",
                            "What factors could you reduce well below the industry standard?",
                            "What factors could you raise well above the industry standard?",
                            "What factors could you create that the industry has never offered?"
                        ],
                        warnings: [
                            "Blue oceans don't stay blue forever—success attracts competition",
                            "Creating new markets is riskier than competing in known ones",
                            "Customers may not know they want something that doesn't exist yet"
                        ],
                        relatedModels: ["First Principles (Generative)", "Reframing", "Combinatorial Thinking"]
                    }
                ]
            },
            implementation: {
                title: "Implementation Models",
                purpose: "Move from decision to effective action",
                coreQuestion: "How do I actually execute this?",
                whenToUse: "After deciding what to do, when planning execution, when building sustainable practices.",
                models: [
                    {
                        name: "Minimum Viable Product (MVP)",
                        description: "Smallest testable version",
                        explanation: "An MVP is the smallest version of your idea that lets you learn whether you're on the right track. It's not about building something minimal and bad—it's about finding the fastest path to validated learning. The goal isn't to ship; it's to learn. What's the smallest thing you can build to test your most critical assumption? Build that, learn, then iterate.",
                        example: "Dropbox's MVP wasn't a working product—it was a 3-minute video demonstrating how the product would work. This tested the critical assumption: 'Do people want simple file syncing?' The video went viral, proving demand before a single line of code was written. The MVP matched the learning need, not the eventual product vision.",
                        prompts: [
                            "What's the riskiest assumption in your plan? How could you test it quickly?",
                            "What's the smallest version that would teach you something valuable?",
                            "What can you remove from the plan and still learn what you need?",
                            "If you only had one week, what would you build to validate the core idea?"
                        ],
                        warnings: [
                            "MVP doesn't mean 'crappy first version'—it should still deliver value",
                            "Some things (safety-critical, trust-dependent) can't be MVP'd",
                            "Learning requires actually launching and getting real feedback, not just building"
                        ],
                        relatedModels: ["Feedback Loops", "Reversible vs. Irreversible Decisions", "80/20 Action"]
                    },
                    {
                        name: "Feedback Loops",
                        description: "Track if this is working",
                        explanation: "Feedback loops are systems where outputs cycle back as inputs, allowing for adjustment and improvement. Fast, accurate feedback is essential for learning and course-correction. Without feedback, you can't know if you're succeeding or failing. The key questions are: What signals tell me this is working? How quickly do I get them? How reliable are they?",
                        example: "A sales team implementing a new script needs feedback loops. Lagging indicator: quarterly revenue (too slow). Leading indicators: call-to-meeting conversion rate (weekly), meeting-to-close rate (weekly), customer satisfaction scores (monthly). By tracking leading indicators, they can adjust the script before quarterly results reveal problems.",
                        prompts: [
                            "How will you know if this is working? What specific metrics or signals?",
                            "How quickly will you get feedback? Can you shorten that cycle?",
                            "What's the difference between leading indicators (early signals) and lagging indicators (final results)?",
                            "What feedback mechanisms need to be built into this plan?"
                        ],
                        warnings: [
                            "Measuring the wrong thing creates bad feedback loops—choose metrics carefully",
                            "Feedback can be gamed; look at multiple signals",
                            "Too much feedback can cause overreaction; not every signal needs a response"
                        ],
                        relatedModels: ["Minimum Viable Product (MVP)", "Systems Thinking", "Compound Interest"]
                    },
                    {
                        name: "Compound Interest",
                        description: "Small actions, exponential results",
                        explanation: "Compound interest isn't just financial—it's a universal principle. Small, consistent actions compound over time into exponential results. The effects are non-linear: 1% improvement daily = 37x improvement annually. The key insight is that early results feel insignificantly small, but the back end of compounding is dramatic. Patience and consistency are required to reach the hockey stick.",
                        example: "Writing for 30 minutes daily seems trivial. Day 1: 500 words. Day 30: 15,000 words. Day 365: 180,000 words—two full books. Plus, your writing skill improves, making each session more productive. The compounding isn't just in output but in capability. Most people overestimate what they can do in a day and underestimate what they can do in a year.",
                        prompts: [
                            "What small action, repeated consistently, would compound over time?",
                            "Where are you expecting immediate results when compounding requires patience?",
                            "What skills, relationships, or assets could you build that grow exponentially?",
                            "What's the 1% improvement you could make today that compounds?"
                        ],
                        warnings: [
                            "Compounding requires consistency—interrupted compound growth resets to zero",
                            "Negative behaviors compound too—bad habits, debt, toxic relationships",
                            "Early compounding feels like nothing is happening; don't give up"
                        ],
                        relatedModels: ["Habit Stacking", "Leverage", "Feedback Loops"]
                    },
                    {
                        name: "Leverage",
                        description: "Small effort, big impact",
                        explanation: "Leverage is getting more output per unit of input. Archimedes said, 'Give me a lever long enough and I shall move the world.' Leverage comes in many forms: tools that multiply effort, skills that command premium value, systems that work while you sleep, relationships that open doors. The highest performers don't work hardest—they find the highest-leverage activities and focus there.",
                        example: "A consultant can trade time for money (low leverage) or create a course that sells while they sleep (high leverage). The course requires the same expertise but scales infinitely. Other leverage: hiring (multiply through others), code (multiply through software), media (multiply through audience), capital (multiply through investment).",
                        prompts: [
                            "Where could you get 10x results from the same effort? What's the leverage point?",
                            "What tools, systems, or relationships could multiply your effectiveness?",
                            "Are you doing high-leverage work, or are you busy with low-leverage tasks?",
                            "What's the one activity where your effort would have disproportionate impact?"
                        ],
                        warnings: [
                            "Leverage amplifies both good and bad decisions—be sure you're right",
                            "High-leverage positions often require building skills or assets first",
                            "Not everything can or should be leveraged—some things require direct effort"
                        ],
                        relatedModels: ["Pareto Principle (80/20)", "80/20 Action", "Compound Interest"]
                    },
                    {
                        name: "Critical Path",
                        description: "Sequence and dependencies",
                        explanation: "The critical path is the longest sequence of dependent tasks that determines the minimum project duration. Tasks on the critical path have zero slack—if any of them slip, the whole project slips. Understanding the critical path reveals where to focus attention, what can be done in parallel, and where delays are fatal. Not all tasks are equal; critical path tasks deserve disproportionate attention.",
                        example: "Building a house: you can't install electrical until walls are up; can't paint until electrical is done; can't move in until paint dries. This is the critical path. Meanwhile, landscaping can happen in parallel—it's not on the critical path. A delay in landscaping doesn't delay move-in; a delay in electrical delays everything downstream.",
                        prompts: [
                            "What tasks must be completed before others can start? Map the dependencies.",
                            "What's the longest chain of dependent tasks? That's your critical path.",
                            "What can be done in parallel while waiting for critical path tasks?",
                            "Where are the bottlenecks? What would happen if they were delayed?"
                        ],
                        warnings: [
                            "The critical path can change as the project evolves—reassess regularly",
                            "Near-critical paths can become critical if they slip",
                            "Dependencies aren't always obvious—hidden dependencies cause surprises"
                        ],
                        relatedModels: ["Redundancy", "Feedback Loops", "80/20 Action"]
                    },
                    {
                        name: "80/20 Action",
                        description: "Focus on highest-impact actions",
                        explanation: "80/20 Action applies the Pareto Principle to execution: identify and focus ruthlessly on the 20% of actions that will drive 80% of results. Most people spread effort evenly across tasks, but impact is not evenly distributed. The discipline is saying no to the merely good so you can say yes to the truly important. Ruthless prioritization beats scattered effort.",
                        example: "A startup founder's to-do list has 50 items. 80/20 analysis reveals: 10 items relate to closing the next big customer (potential: company survival). 40 items are 'nice to have' operational improvements. Focus intensely on the 10 items. The 40 can wait or be delegated. The founder who does everything does nothing important.",
                        prompts: [
                            "Of all the things you could do, which few will drive most of the results?",
                            "What's on your list that feels productive but doesn't actually move the needle?",
                            "If you could only accomplish 3 things this week, which would matter most?",
                            "What would you stop doing if you were forced to cut half your activities?"
                        ],
                        warnings: [
                            "The vital few change over time; what was 80/20 yesterday may not be today",
                            "Some foundational work doesn't show immediate results but enables later 80/20",
                            "Extreme focus can cause you to miss important but non-obvious opportunities"
                        ],
                        relatedModels: ["Pareto Principle (80/20)", "Leverage", "Critical Path"]
                    },
                    {
                        name: "Habit Stacking",
                        description: "Link to established routines",
                        explanation: "Habit stacking links new behaviors to existing habits, using established routines as triggers for new ones. The formula: 'After I [existing habit], I will [new habit].' This works because existing habits are already wired into your brain's autopilot. By attaching new behaviors to existing ones, you borrow the existing habit's triggering power. The chain of habits becomes a single automatic routine.",
                        example: "Goal: daily journaling. Existing habit: morning coffee. Stack: 'After I pour my morning coffee, I will write in my journal for 5 minutes.' The coffee triggers the journaling automatically. Over time, the stack becomes: coffee → journal → review calendar → start top priority task. One anchor habit can trigger an entire morning routine.",
                        prompts: [
                            "What habits do you already do reliably every day? List them.",
                            "What new behavior do you want to establish?",
                            "After which existing habit could you naturally insert the new behavior?",
                            "What's the smallest version of the new habit you could stack? (Start tiny)"
                        ],
                        warnings: [
                            "The trigger habit must be reliable—don't stack on inconsistent behaviors",
                            "Start with tiny habits; don't stack ambitious behaviors onto existing routines",
                            "If the stack breaks, rebuild from the most reliable anchor habit"
                        ],
                        relatedModels: ["Compound Interest", "Feedback Loops", "Minimum Viable Product (MVP)"]
                    }
                ]
            }
        };

        // Problem Types and Their Relevant Models
        const problemTypes = {
            strategic: {
                name: "Strategic Decision",
                description: "Long-term direction, business strategy, major pivots, market positioning",
                models: {
                    diagnostic: ["First Principles", "Systems Thinking", "Confirmation Bias Recognition"],
                    evaluative: ["Second-Order Thinking", "Opportunity Cost", "Expected Value", "Pareto Principle (80/20)"],
                    protective: ["Pre-mortem", "Reversible vs. Irreversible Decisions", "Inversion"],
                    generative: ["First Principles (Generative)", "Blue Ocean Strategy", "Reframing", "Constraint Removal"],
                    implementation: ["Critical Path", "Feedback Loops", "80/20 Action"]
                }
            },
            operational: {
                name: "Operational Problem",
                description: "Process improvement, efficiency, workflows, resource allocation, team coordination",
                models: {
                    diagnostic: ["Root Cause Analysis", "Systems Thinking", "Occam's Razor"],
                    evaluative: ["Pareto Principle (80/20)", "Cost-Benefit Analysis", "Opportunity Cost"],
                    protective: ["Margin of Safety", "Redundancy", "Inversion"],
                    generative: ["Constraint Removal", "Combinatorial Thinking", "Lateral Thinking"],
                    implementation: ["Critical Path", "Leverage", "80/20 Action", "Feedback Loops"]
                }
            },
            interpersonal: {
                name: "People/Team Issue",
                description: "Conflict resolution, hiring, firing, team dynamics, communication, leadership",
                models: {
                    diagnostic: ["Circle of Competence", "Confirmation Bias Recognition", "Root Cause Analysis"],
                    evaluative: ["Incentives", "Second-Order Thinking", "Opportunity Cost"],
                    protective: ["Pre-mortem", "Reversible vs. Irreversible Decisions", "Margin of Safety"],
                    generative: ["Reframing", "Lateral Thinking", "Analogical Thinking"],
                    implementation: ["Feedback Loops", "Habit Stacking", "Minimum Viable Product (MVP)"]
                }
            },
            technical: {
                name: "Technical/Analytical Problem",
                description: "Debugging, troubleshooting, data analysis, system design, technical architecture",
                models: {
                    diagnostic: ["Occam's Razor", "Root Cause Analysis", "First Principles", "Systems Thinking"],
                    evaluative: ["Cost-Benefit Analysis", "Expected Value", "Satisficing vs. Optimizing"],
                    protective: ["Margin of Safety", "Redundancy", "Pre-mortem", "Antifragility"],
                    generative: ["First Principles (Generative)", "Constraint Removal", "Combinatorial Thinking"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Critical Path"]
                }
            },
            personal: {
                name: "Personal Decision",
                description: "Career change, major purchase, relationship, lifestyle, health, financial planning",
                models: {
                    diagnostic: ["Circle of Competence", "Confirmation Bias Recognition", "First Principles"],
                    evaluative: ["Opportunity Cost", "Second-Order Thinking", "Expected Value", "Satisficing vs. Optimizing"],
                    protective: ["Reversible vs. Irreversible Decisions", "Pre-mortem", "Inversion", "Margin of Safety"],
                    generative: ["Reframing", "Constraint Removal", "Lateral Thinking"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Habit Stacking", "Compound Interest"]
                }
            },
            creative: {
                name: "Innovation/Creative Challenge",
                description: "New product, creative project, innovation, breaking into new markets, differentiation",
                models: {
                    diagnostic: ["First Principles", "Confirmation Bias Recognition", "Systems Thinking"],
                    evaluative: ["Opportunity Cost", "Second-Order Thinking", "Pareto Principle (80/20)"],
                    protective: ["Reversible vs. Irreversible Decisions", "Antifragility", "Pre-mortem"],
                    generative: ["First Principles (Generative)", "Blue Ocean Strategy", "Combinatorial Thinking", "Lateral Thinking", "Constraint Removal", "Analogical Thinking", "Reframing"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Leverage"]
                }
            }
        };

        // State Management
        let currentPhase = 'diagnostic';
        let selectedModel = null;
        let logEntries = [];
        let nextLogId = 1;
        let problemDescribed = false;
        let problemType = null;

        // DOM Elements
        const container = document.querySelector('.container');
        const problemReference = document.getElementById('problemReference');
        const problemReferenceText = document.getElementById('problemReferenceText');
        const problemTypeSelector = document.getElementById('problemTypeSelector');
        const problemTypesGrid = document.getElementById('problemTypesGrid');
        const continueBtn = document.getElementById('continueBtn');
        const phaseButtons = document.querySelectorAll('.phase-btn');
        const phaseNavigation = document.querySelector('.phase-navigation');
        const modelsSection = document.querySelector('.models-section');
        const workArea = document.querySelector('.work-area');
        const mainContent = document.querySelector('.main-content');
        const modelsGrid = document.getElementById('modelsGrid');
        const phaseDescription = document.getElementById('phaseDescription');
        const selectedModelDisplay = document.getElementById('selectedModelDisplay');
        const responseInput = document.getElementById('responseInput');
        const saveBtn = document.getElementById('saveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const logEntriesContainer = document.getElementById('logEntries');
        const notepadArea = document.getElementById('notepadArea');
        const clearNotepadBtn = document.getElementById('clearNotepad');
        const copyNotepadBtn = document.getElementById('copyNotepad');
        
        // Legacy panel elements (keeping for backward compatibility)
        const panelLeft = null; // Removed in new layout
        const panelRight = null; // Replaced by rightPanel
        const logToggle = null; // Removed in new layout
        const notepadToggle = null; // Removed in new layout
        const panelLeftClose = null; // Removed in new layout
        const panelRightClose = null; // Replaced by rightPanelClose

        // New UI elements
        const workAreaContent = document.getElementById('workAreaContent');
        const confirmModal = document.getElementById('confirmModal');
        const modalCancel = document.getElementById('modalCancel');
        const modalConfirm = document.getElementById('modalConfirm');
        const decisionSummary = document.getElementById('decisionSummary');
        const summaryInput = document.getElementById('summaryInput');
        const saveSummaryBtn = document.getElementById('saveSummaryBtn');
        const exportSessionBtn = document.getElementById('exportSessionBtn');
        const sortNewestBtn = document.getElementById('sortNewest');
        const sortOldestBtn = document.getElementById('sortOldest');

        // State
        let logSortOrder = 'newest'; // 'newest' or 'oldest'

        // Sidebar elements
        const sidebar = document.getElementById('sidebar');
        const sidebarGreeting = document.getElementById('sidebarGreeting');
        const phaseSidebarItems = document.querySelectorAll('.phase-sidebar-item');
        const navHome = document.getElementById('navHome');
        const navNotepad = document.getElementById('navNotepad');
        const navLog = document.getElementById('navLog');
        const logCountLabel = document.getElementById('logCount');
        const startOverSidebar = document.getElementById('startOverSidebar');

        // Right panel elements
        const rightPanel = document.getElementById('rightPanel');
        const rightPanelToggle = document.getElementById('rightPanelToggle');
        const rightPanelClose = document.getElementById('rightPanelClose');
        const tabLog = document.getElementById('tabLog');
        const tabNotepad = document.getElementById('tabNotepad');
        const logSection = document.getElementById('logSection');
        const notepadSection = document.getElementById('notepadSection');

        // Dashboard elements
        const dashboardGrid = document.getElementById('dashboardGrid');
        const dashboardProblem = document.getElementById('dashboardProblem');
        const editProblem = document.getElementById('editProblem');
        const progressOverview = document.getElementById('progressOverview');

        // Quick action buttons
        const quickSuggest = document.getElementById('quickSuggest');
        const quickProgress = document.getElementById('quickProgress');
        const quickExport = document.getElementById('quickExport');

        // Render Problem Type Selector
        function renderProblemTypeSelector() {
            problemTypesGrid.innerHTML = '';
            
            Object.keys(problemTypes).forEach(typeKey => {
                const type = problemTypes[typeKey];
                const card = document.createElement('div');
                card.className = 'problem-type-card';
                card.dataset.typeKey = typeKey;
                card.innerHTML = `
                    <div class="problem-type-name">${type.name}</div>
                    <div class="problem-type-description">${type.description}</div>
                `;
                card.addEventListener('click', () => selectProblemType(typeKey, card));
                problemTypesGrid.appendChild(card);
            });
        }

        // Select Problem Type
        function selectProblemType(typeKey, card) {
            // Clear previous selection
            document.querySelectorAll('.problem-type-card').forEach(c => c.classList.remove('selected'));
            
            // Set new selection
            card.classList.add('selected');
            problemType = typeKey;
            
            // Show continue button
            continueBtn.classList.add('visible');
        }

        // Continue After Problem Type Selection
        function continueToProblemSolving() {
            // Hide problem type selector
            problemTypeSelector.classList.remove('visible');
            
            // Reveal the decision-making sections with filtered models
            setTimeout(() => {
                revealSections();
            }, 300);
        }

        // Initialize
        function init() {
            showInitialPrompt();
            renderPhaseContent();
            setupEventListeners();
            setupDrawers();
            setupSidebar();
            setupRightPanel();
            setupQuickActions();
            setupDashboard();
            loadFromLocalStorage();
            updateProgressTracking();
            updateWelcomeGreeting();
        }

        // Show Initial Prompt
        function showInitialPrompt() {
            selectedModelDisplay.className = 'selected-model-display initial';
            selectedModelDisplay.innerHTML = `
                <div class="instruction-text">Welcome! Let's start with your decision or problem.</div>
                <div class="instruction-subtext">Before exploring mental models, describe the situation you're facing. What decision do you need to make? What problem are you trying to solve?</div>
            `;
            responseInput.placeholder = "Describe your decision or problem here...";
            responseInput.classList.add('initial-entry');
            saveBtn.textContent = 'Add to Log';
        }

        // Setup Panel Controls
        function setupDrawers() {
            // Sort button listeners
            if (sortNewestBtn) {
                sortNewestBtn.addEventListener('click', () => {
                    logSortOrder = 'newest';
                    sortNewestBtn.classList.add('active');
                    sortOldestBtn.classList.remove('active');
                    renderLogEntries();
                });
            }

            if (sortOldestBtn) {
                sortOldestBtn.addEventListener('click', () => {
                    logSortOrder = 'oldest';
                    sortOldestBtn.classList.add('active');
                    sortNewestBtn.classList.remove('active');
                    renderLogEntries();
                });
            }

            // Modal listeners
            if (modalCancel) modalCancel.addEventListener('click', closeConfirmModal);
            if (modalConfirm) modalConfirm.addEventListener('click', confirmStartOver);

            // Decision summary listeners
            if (saveSummaryBtn) saveSummaryBtn.addEventListener('click', saveSummaryToLog);
            if (exportSessionBtn) exportSessionBtn.addEventListener('click', downloadSession);
        }

        // Setup Sidebar Navigation
        function setupSidebar() {
            // Phase sidebar items - click to navigate to phase
            phaseSidebarItems.forEach(item => {
                item.addEventListener('click', () => {
                    const phase = item.dataset.phase;
                    if (phase) {
                        currentPhase = phase;
                        updatePhaseButtons();
                        renderPhaseContent();
                        clearSelection();
                        updateSidebarActivePhase();

                        // Show models section if problem is described
                        if (problemDescribed) {
                            modelsSection.classList.add('revealed');
                            phaseNavigation.classList.add('revealed');
                        }
                    }
                });
            });

            // Quick access navigation
            if (navHome) {
                navHome.addEventListener('click', () => {
                    // Scroll to top / show dashboard
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    updateSidebarQuickAccess('home');
                });
            }

            if (navNotepad) {
                navNotepad.addEventListener('click', () => {
                    openRightPanelTab('notepad');
                    updateSidebarQuickAccess('notepad');
                });
            }

            if (navLog) {
                navLog.addEventListener('click', () => {
                    openRightPanelTab('log');
                    updateSidebarQuickAccess('log');
                });
            }

            // Start Over button in sidebar
            if (startOverSidebar) {
                startOverSidebar.addEventListener('click', startOver);
            }
        }

        // Update sidebar active phase highlight
        function updateSidebarActivePhase() {
            phaseSidebarItems.forEach(item => {
                item.classList.toggle('active', item.dataset.phase === currentPhase);
            });
        }

        // Update sidebar quick access highlight
        function updateSidebarQuickAccess(active) {
            if (navHome) navHome.classList.toggle('active', active === 'home');
            if (navNotepad) navNotepad.classList.toggle('active', active === 'notepad');
            if (navLog) navLog.classList.toggle('active', active === 'log');
        }

        // Setup Right Panel with Tabs
        function setupRightPanel() {
            // Toggle button
            if (rightPanelToggle) {
                rightPanelToggle.addEventListener('click', () => {
                    rightPanel.classList.toggle('open');
                    rightPanelToggle.classList.toggle('active');
                });
            }

            // Close button
            if (rightPanelClose) {
                rightPanelClose.addEventListener('click', () => {
                    rightPanel.classList.remove('open');
                    rightPanelToggle.classList.remove('active');
                });
            }

            // Tab switching
            if (tabLog) {
                tabLog.addEventListener('click', () => switchPanelTab('log'));
            }
            if (tabNotepad) {
                tabNotepad.addEventListener('click', () => switchPanelTab('notepad'));
            }
        }

        // Switch between Log and Notepad tabs
        function switchPanelTab(tab) {
            if (tab === 'log') {
                tabLog.classList.add('active');
                tabNotepad.classList.remove('active');
                logSection.classList.add('active');
                notepadSection.classList.remove('active');
            } else {
                tabNotepad.classList.add('active');
                tabLog.classList.remove('active');
                notepadSection.classList.add('active');
                logSection.classList.remove('active');
            }
        }

        // Open right panel with specific tab
        function openRightPanelTab(tab) {
            rightPanel.classList.add('open');
            rightPanelToggle.classList.add('active');
            switchPanelTab(tab);
        }

        // Setup Quick Action Buttons
        function setupQuickActions() {
            if (quickSuggest) {
                quickSuggest.addEventListener('click', () => {
                    // Suggest a model based on current state
                    if (!problemDescribed) {
                        alert('Please describe your problem first before getting model suggestions.');
                        return;
                    }
                    // Scroll to models section
                    if (modelsSection) {
                        modelsSection.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }

            if (quickProgress) {
                quickProgress.addEventListener('click', () => {
                    // Show progress overview
                    if (dashboardGrid) {
                        dashboardGrid.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }

            if (quickExport) {
                quickExport.addEventListener('click', downloadSession);
            }
        }

        // Setup Dashboard
        function setupDashboard() {
            if (editProblem) {
                editProblem.addEventListener('click', () => {
                    // Focus on the response input for editing
                    if (responseInput) {
                        responseInput.focus();
                        responseInput.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }

            // Initial dashboard render
            updateDashboard();
        }

        // Update Dashboard
        function updateDashboard() {
            // Update problem display
            if (dashboardProblem) {
                const initialEntry = logEntries.find(e => e.phase === 'initial');
                if (initialEntry) {
                    const truncated = initialEntry.response.length > 150
                        ? initialEntry.response.substring(0, 150) + '...'
                        : initialEntry.response;
                    dashboardProblem.textContent = truncated;
                } else {
                    dashboardProblem.textContent = 'No problem defined yet. Start by describing your decision or problem.';
                }
            }

            // Update progress overview
            if (progressOverview) {
                renderProgressOverview();
            }
        }

        // Render Progress Overview in Dashboard
        function renderProgressOverview() {
            const phases = ['diagnostic', 'evaluative', 'protective', 'generative', 'implementation'];
            const phaseNames = {
                diagnostic: 'Diagnose',
                evaluative: 'Evaluate',
                protective: 'Protect',
                generative: 'Generate',
                implementation: 'Implement'
            };
            const phaseColors = {
                diagnostic: 'var(--diagnostic-color)',
                evaluative: 'var(--evaluative-color)',
                protective: 'var(--protective-color)',
                generative: 'var(--generative-color)',
                implementation: 'var(--implementation-color)'
            };

            let html = '';
            phases.forEach((phase, index) => {
                const phaseData = mentalModelsData[phase];
                const totalModels = phaseData.models.length;
                const usedModels = logEntries.filter(e => e.phase === phase).length;
                const percentage = Math.round((usedModels / totalModels) * 100);

                html += `
                    <div class="progress-phase-row">
                        <div class="progress-phase-icon" style="background: ${phaseColors[phase]}">${index + 1}</div>
                        <div class="progress-phase-info">
                            <div class="progress-phase-name">${phaseNames[phase]}</div>
                            <div class="progress-phase-bar">
                                <div class="progress-phase-fill" style="width: ${percentage}%; background: ${phaseColors[phase]}"></div>
                            </div>
                        </div>
                        <div class="progress-phase-percent">${percentage}%</div>
                    </div>
                `;
            });

            progressOverview.innerHTML = html;
        }

        // Update Progress Tracking (sidebar and dashboard)
        function updateProgressTracking() {
            const phases = ['diagnostic', 'evaluative', 'protective', 'generative', 'implementation'];

            phases.forEach(phase => {
                const phaseData = mentalModelsData[phase];
                const totalModels = phaseData.models.length;
                const usedModels = logEntries.filter(e => e.phase === phase).length;
                const percentage = Math.round((usedModels / totalModels) * 100);

                // Update sidebar progress bar
                const progressBar = document.getElementById(`progress${phase.charAt(0).toUpperCase() + phase.slice(1)}`);
                if (progressBar) {
                    progressBar.style.width = `${percentage}%`;
                }

                // Update sidebar progress text
                const progressText = document.getElementById(`progressText${phase.charAt(0).toUpperCase() + phase.slice(1)}`);
                if (progressText) {
                    progressText.textContent = `${usedModels}/${totalModels} models`;
                }

                // Update status badge
                const statusBadge = document.getElementById(`status${phase.charAt(0).toUpperCase() + phase.slice(1)}`);
                if (statusBadge) {
                    if (usedModels === 0) {
                        statusBadge.textContent = 'Not Started';
                        statusBadge.className = 'status-badge not-started';
                    } else if (usedModels >= totalModels) {
                        statusBadge.textContent = 'Completed';
                        statusBadge.className = 'status-badge completed';
                    } else {
                        statusBadge.textContent = 'In Progress';
                        statusBadge.className = 'status-badge in-progress';
                    }
                }
            });

            // Update log count in sidebar
            if (logCountLabel) {
                const entryCount = logEntries.filter(e => e.phase !== 'initial' && e.phase !== 'summary').length;
                logCountLabel.textContent = `${entryCount} ${entryCount === 1 ? 'entry' : 'entries'}`;
            }

            // Update dashboard
            updateDashboard();
        }

        // Update Welcome Greeting
        function updateWelcomeGreeting() {
            if (!sidebarGreeting) return;

            const hour = new Date().getHours();
            let greeting;
            if (hour < 12) {
                greeting = 'Good morning!';
            } else if (hour < 17) {
                greeting = 'Good afternoon!';
            } else {
                greeting = 'Good evening!';
            }

            // Check if returning user
            if (logEntries.length > 0) {
                greeting = 'Welcome back!';
            }

            sidebarGreeting.textContent = greeting;
        }

        // Modal functions
        function showConfirmModal() {
            confirmModal.classList.add('visible');
        }

        function closeConfirmModal() {
            confirmModal.classList.remove('visible');
        }

        function confirmStartOver() {
            closeConfirmModal();
            resetApp();
        }

        // Save summary to log
        function saveSummaryToLog() {
            const summaryText = summaryInput.value.trim();
            if (!summaryText) {
                alert('Please write your decision summary before saving.');
                return;
            }

            const entry = {
                id: nextLogId++,
                phase: 'summary',
                modelName: 'Decision Summary',
                modelPrompt: 'Final synthesis of mental model analysis',
                response: summaryText,
                timestamp: new Date().toLocaleString()
            };

            logEntries.unshift(entry);
            renderLogEntries();
            saveToLocalStorage();
            openRightPanel();

            // Clear the summary input
            summaryInput.value = '';

            alert('Decision summary saved to log!');
        }

        // Show decision summary after enough meaningful work is done
        function checkShowDecisionSummary() {
            // Filter out initial problem description and summary entries
            const workEntries = logEntries.filter(e => e.phase !== 'initial' && e.phase !== 'summary');

            // Get unique phases from work entries
            const uniquePhases = new Set(workEntries.map(e => e.phase));

            // Show decision summary when user has applied at least 3 mental models from at least 2 different phases
            if (uniquePhases.size >= 2 && workEntries.length >= 3) {
                decisionSummary.classList.add('visible');
            } else {
                decisionSummary.classList.remove('visible');
            }
        }

        function toggleRightPanel() {
            if (rightPanel) {
                rightPanel.classList.toggle('open');
                rightPanelToggle.classList.toggle('active');
            }
        }

        function toggleLeftPanel() {
            // Left panel removed in new layout - open sidebar instead on mobile
            if (sidebar) {
                sidebar.classList.toggle('open');
            }
        }

        function closeRightPanel() {
            if (rightPanel) {
                rightPanel.classList.remove('open');
                rightPanelToggle.classList.remove('active');
            }
        }

        function closeLeftPanel() {
            if (sidebar) {
                sidebar.classList.remove('open');
            }
        }

        function openRightPanel() {
            if (rightPanel) {
                rightPanel.classList.add('open');
                rightPanelToggle.classList.add('active');
            }
        }

        function openLeftPanel() {
            if (sidebar) {
                sidebar.classList.add('open');
            }
        }

        // Setup Event Listeners
        function setupEventListeners() {
            phaseButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    currentPhase = btn.dataset.phase;
                    updatePhaseButtons();
                    renderPhaseContent();
                    clearSelection();
                });
            });

            if (saveBtn) saveBtn.addEventListener('click', saveToLog);
            if (clearBtn) clearBtn.addEventListener('click', clearCurrentResponse);
            if (startOverBtn) startOverBtn.addEventListener('click', startOver);
            if (continueBtn) continueBtn.addEventListener('click', continueToProblemSolving);
            if (clearNotepadBtn) clearNotepadBtn.addEventListener('click', clearNotepad);
            if (copyNotepadBtn) copyNotepadBtn.addEventListener('click', copyNotepad);

            // Drag and drop for notepad
            if (notepadArea) {
                notepadArea.addEventListener('dragover', handleDragOver);
                notepadArea.addEventListener('drop', handleDrop);
                notepadArea.addEventListener('dragleave', handleDragLeave);
            }
        }

        // Update Phase Buttons
        function updatePhaseButtons() {
            phaseButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.phase === currentPhase);
            });
        }

        // Render Phase Content
        function renderPhaseContent() {
            const phaseData = mentalModelsData[currentPhase];
            
            // Update phase description
            phaseDescription.className = `phase-description ${currentPhase}`;
            phaseDescription.innerHTML = `
                <h3>${phaseData.title}</h3>
                <p><strong>Purpose:</strong> ${phaseData.purpose}</p>
                <p class="core-question">${phaseData.coreQuestion}</p>
            `;

            // Filter models based on problem type
            let modelsToShow = phaseData.models;
            if (problemType && problemTypes[problemType]) {
                const relevantModelNames = problemTypes[problemType].models[currentPhase];
                if (relevantModelNames) {
                    modelsToShow = phaseData.models.filter(model => 
                        relevantModelNames.includes(model.name)
                    );
                }
            }

            // Render models
            modelsGrid.innerHTML = '';
            modelsToShow.forEach((model, index) => {
                const modelCard = document.createElement('div');
                modelCard.className = `model-card ${currentPhase}`;
                modelCard.dataset.modelIndex = index;
                modelCard.innerHTML = `
                    <div class="model-name">${model.name}</div>
                    <div class="model-description">${model.description}</div>
                `;
                modelCard.addEventListener('click', () => selectModel(model, modelCard));
                modelsGrid.appendChild(modelCard);
            });
            
            // Show message if no models match
            if (modelsToShow.length === 0) {
                modelsGrid.innerHTML = '<div class="empty-state">No models match this problem type for this phase. Try another phase or problem type.</div>';
            }
        }

        // Select Model
        function selectModel(model, card) {
            // If problem hasn't been described yet, save it first
            if (!problemDescribed && responseInput.value.trim()) {
                saveProblemDescription();
                return; // Let the save process complete
            }

            // Clear previous selection
            document.querySelectorAll('.model-card').forEach(c => c.classList.remove('selected'));

            // Set new selection
            card.classList.add('selected');
            selectedModel = { ...model, phase: currentPhase };

            // Check if this model has expanded content
            if (model.prompts && model.explanation) {
                // Enable split-pane layout
                workAreaContent.classList.add('split-pane');

                // Render expanded model display
                selectedModelDisplay.className = 'selected-model-display expanded';
                selectedModelDisplay.innerHTML = renderExpandedModel(model);

                // Set up prompt selection handlers
                setupPromptSelection();

                // Set up collapsible section handlers
                setupCollapsibleSections();

                // Set up related model click handlers
                setupRelatedModelLinks();
            } else {
                // Remove split-pane for simple models
                workAreaContent.classList.remove('split-pane');

                // Fallback to simple display for models not yet expanded
                selectedModelDisplay.className = 'selected-model-display';
                selectedModelDisplay.innerHTML = `
                    <div class="model-prompt"><strong>${model.name}</strong></div>
                    <div>${model.prompt}</div>
                `;
            }

            // Reset placeholder and button for model response
            responseInput.placeholder = "Apply this mental model to your situation...";
            responseInput.classList.remove('initial-entry');
            saveBtn.textContent = 'Add to Log';

            // Focus textarea
            responseInput.focus();
        }

        // Render expanded model content
        function renderExpandedModel(model) {
            const promptsHtml = model.prompts.map((prompt, index) =>
                `<li data-prompt="${escapeHtml(prompt)}">${prompt}</li>`
            ).join('');

            const warningsHtml = model.warnings ? model.warnings.map(w =>
                `<li>${w}</li>`
            ).join('') : '';

            const relatedHtml = model.relatedModels ? model.relatedModels.map(r =>
                `<span class="model-related-tag" data-model="${escapeHtml(r)}">${r}</span>`
            ).join('') : '';

            return `
                <div class="model-header">
                    <h3>${model.name}</h3>
                    <div class="model-tagline">${model.description}</div>
                </div>

                <div class="model-section collapsible">
                    <div class="model-section-header" data-section="explanation">
                        <div class="model-section-title">What It Is</div>
                        <span class="model-section-toggle">▼</span>
                    </div>
                    <div class="model-section-body">
                        <div class="model-explanation">${model.explanation}</div>
                    </div>
                </div>

                <div class="model-section collapsible">
                    <div class="model-section-header" data-section="example">
                        <div class="model-section-title">Example</div>
                        <span class="model-section-toggle">▼</span>
                    </div>
                    <div class="model-section-body">
                        <div class="model-example">${model.example}</div>
                    </div>
                </div>

                <div class="model-section collapsible">
                    <div class="model-section-header" data-section="prompts">
                        <div class="model-section-title">Questions to Ask</div>
                        <span class="model-section-toggle">▼</span>
                    </div>
                    <div class="model-section-body">
                        <div class="prompt-instruction">Click a question to use it as your prompt:</div>
                        <ul class="model-prompts-list">
                            ${promptsHtml}
                        </ul>
                    </div>
                </div>

                ${model.warnings ? `
                <div class="model-section collapsible">
                    <div class="model-section-header collapsed" data-section="warnings">
                        <div class="model-section-title">Watch Out For</div>
                        <span class="model-section-toggle">▼</span>
                    </div>
                    <div class="model-section-body">
                        <div class="model-warnings">
                            <ul>${warningsHtml}</ul>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${model.relatedModels ? `
                <div class="model-section collapsible">
                    <div class="model-section-header collapsed" data-section="related">
                        <div class="model-section-title">Related Models</div>
                        <span class="model-section-toggle">▼</span>
                    </div>
                    <div class="model-section-body">
                        <div class="model-related">${relatedHtml}</div>
                    </div>
                </div>
                ` : ''}
            `;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Set up click handlers for prompt selection
        function setupPromptSelection() {
            const promptItems = document.querySelectorAll('.model-prompts-list li');
            promptItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Remove selection from others
                    promptItems.forEach(p => p.classList.remove('selected-prompt'));
                    // Add selection to clicked
                    this.classList.add('selected-prompt');

                    // Update the selected model's active prompt
                    const selectedPrompt = this.getAttribute('data-prompt');
                    if (selectedModel) {
                        selectedModel.activePrompt = selectedPrompt;
                    }

                    // Update placeholder to show the selected question
                    responseInput.placeholder = `Respond to: "${selectedPrompt.substring(0, 60)}${selectedPrompt.length > 60 ? '...' : ''}"`;
                    responseInput.focus();
                });
            });

            // Auto-select first prompt
            if (promptItems.length > 0) {
                promptItems[0].click();
            }
        }

        // Set up collapsible section handlers
        function setupCollapsibleSections() {
            const sectionHeaders = document.querySelectorAll('.model-section-header');
            sectionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    this.classList.toggle('collapsed');
                });
            });
        }

        // Set up related model click handlers
        function setupRelatedModelLinks() {
            const relatedTags = document.querySelectorAll('.model-related-tag');
            relatedTags.forEach(tag => {
                tag.addEventListener('click', function() {
                    const modelName = this.getAttribute('data-model');
                    navigateToModel(modelName);
                });
            });
        }

        // Navigate to a model by name
        function navigateToModel(modelName) {
            // Search through all phases to find the model
            for (const [phaseKey, phaseData] of Object.entries(mentalModelsData)) {
                const model = phaseData.models.find(m => m.name === modelName);
                if (model) {
                    // Switch to that phase
                    currentPhase = phaseKey;
                    updatePhaseButtons();
                    renderPhaseContent();

                    // Find and click the model card after a short delay for rendering
                    setTimeout(() => {
                        const modelCards = document.querySelectorAll('.model-card');
                        modelCards.forEach(card => {
                            if (card.querySelector('.model-name').textContent === modelName) {
                                card.click();
                                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        });
                    }, 100);
                    return;
                }
            }
        }

        // Create Flying Entry Animation
        function createFlyingEntry(text) {
            // Get the position of the work area
            const workArea = document.querySelector('.work-area');
            const workRect = workArea.getBoundingClientRect();
            
            // Create the flying element
            const flyingEl = document.createElement('div');
            flyingEl.className = 'flying-entry';
            flyingEl.style.left = `${workRect.left}px`;
            flyingEl.style.top = `${workRect.top + 100}px`;
            flyingEl.innerHTML = `
                <div class="flying-title">Problem Description</div>
                <div class="flying-text">${text}</div>
            `;
            
            document.body.appendChild(flyingEl);
            
            // Remove after animation completes
            setTimeout(() => {
                flyingEl.remove();
            }, 800);
        }

        // Reveal Sections
        function revealSections() {
            // Move phase navigation and models section before work area
            mainContent.insertBefore(phaseNavigation, workArea);
            mainContent.insertBefore(modelsSection, workArea);
            
            // Reveal phase navigation first
            phaseNavigation.classList.add('revealed');
            
            // Then reveal models section with a slight delay
            setTimeout(() => {
                modelsSection.classList.add('revealed');
            }, 100);
            
            // Slide work area down
            setTimeout(() => {
                workArea.classList.add('slide-down');
            }, 200);
        }

        // Save Problem Description
        function saveProblemDescription() {
            const description = responseInput.value.trim();
            if (!description) return;

            // Create flying animation
            createFlyingEntry(description);

            const entry = {
                id: nextLogId++,
                phase: 'initial',
                modelName: 'Problem Description',
                modelPrompt: 'What decision or problem are you trying to solve?',
                response: description,
                timestamp: new Date().toLocaleString()
            };

            logEntries.unshift(entry);
            problemDescribed = true;
            
            // Show problem reference banner
            problemReferenceText.textContent = description;
            setTimeout(() => {
                problemReference.classList.add('visible');
            }, 100);
            
            // Delay log rendering and panel opening to sync with animation
            setTimeout(() => {
                renderLogEntries();
                saveToLocalStorage();
                updateDashboard();

                // Open decision log panel
                openRightPanelTab('log');
            }, 400);
            
            // Add problem description to notepad automatically
            if (notepadArea) {
                notepadArea.innerText = `PROBLEM/DECISION:\n${description}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
                notepadArea.classList.remove('empty');
            }
            
            // Show problem type selector after brief delay
            setTimeout(() => {
                problemTypeSelector.classList.add('visible');
                renderProblemTypeSelector();
            }, 900);
            
            // Clear the textarea and reset styling
            responseInput.value = '';
            responseInput.classList.remove('initial-entry');
            saveBtn.textContent = 'Add to Log';
        }

        // Clear Selection
        function clearSelection() {
            selectedModel = null;
            document.querySelectorAll('.model-card').forEach(c => c.classList.remove('selected'));
            
            if (!problemDescribed) {
                showInitialPrompt();
            } else {
                selectedModelDisplay.className = 'selected-model-display empty';
                selectedModelDisplay.innerHTML = 'Select a mental model to continue...';
                responseInput.placeholder = "Apply this mental model to your situation...";
            }
        }

        // Save to Log
        function saveToLog() {
            // If we haven't described the problem yet, save the problem description
            if (!problemDescribed) {
                if (!responseInput.value.trim()) {
                    alert('Please describe your decision or problem before continuing.');
                    return;
                }
                saveProblemDescription();
                return;
            }
            
            // Otherwise, save a mental model response
            if (!selectedModel || !responseInput.value.trim()) {
                alert('Please select a mental model and enter your response.');
                return;
            }

            const entry = {
                id: nextLogId++,
                phase: selectedModel.phase,
                modelName: selectedModel.name,
                modelPrompt: selectedModel.activePrompt || selectedModel.prompt,
                response: responseInput.value.trim(),
                timestamp: new Date().toLocaleString()
            };

            logEntries.unshift(entry);
            renderLogEntries();
            clearCurrentResponse();
            saveToLocalStorage();

            // Update progress tracking
            updateProgressTracking();

            // Open decision log panel
            openRightPanelTab('log');

            // Check if we should show decision summary
            checkShowDecisionSummary();
        }

        // Render Log Entries
        function renderLogEntries() {
            if (logEntries.length === 0) {
                logEntriesContainer.innerHTML = '<div class="empty-state">No entries yet. Start by selecting a mental model and responding.</div>';
                return;
            }

            // Sort entries based on current sort order
            const sortedEntries = [...logEntries].sort((a, b) => {
                if (logSortOrder === 'oldest') {
                    return a.id - b.id;
                }
                return b.id - a.id; // newest first (default)
            });

            logEntriesContainer.innerHTML = '';
            sortedEntries.forEach(entry => {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${entry.phase}`;
                logEntry.draggable = true;
                logEntry.dataset.entryId = entry.id;

                // Show prompt if available
                const promptHtml = entry.modelPrompt ?
                    `<div class="log-prompt">"${entry.modelPrompt}"</div>` : '';

                logEntry.innerHTML = `
                    <div class="log-entry-header">
                        <div class="log-model-name">${entry.modelName}</div>
                        <div class="log-actions">
                            <button class="log-action-btn" onclick="editEntry(${entry.id})" title="Edit">✏️</button>
                            <button class="log-action-btn" onclick="deleteEntry(${entry.id})" title="Delete">🗑️</button>
                        </div>
                    </div>
                    ${promptHtml}
                    <div class="log-content">${entry.response}</div>
                    <div class="log-timestamp">${entry.timestamp}</div>
                `;

                // Add drag event listeners
                logEntry.addEventListener('dragstart', handleDragStart);
                logEntriesContainer.appendChild(logEntry);
            });
        }

        // Start Over - Show confirmation modal
        function startOver() {
            showConfirmModal();
        }

        // Download Session as Text File
        function downloadSession() {
            let content = 'MENTAL MODELS DECISION-MAKING SESSION\n';
            content += '=' .repeat(60) + '\n';
            content += `Date: ${new Date().toLocaleString()}\n\n`;
            
            // Add problem description if exists
            const problemEntry = logEntries.find(e => e.phase === 'initial');
            if (problemEntry) {
                content += 'PROBLEM/DECISION:\n';
                content += problemEntry.response + '\n\n';
                content += '=' .repeat(60) + '\n\n';
            }
            
            // Add all mental model responses grouped by phase
            const phases = ['diagnostic', 'evaluative', 'protective', 'generative', 'implementation'];
            const phaseNames = {
                diagnostic: 'DIAGNOSTIC PHASE',
                evaluative: 'EVALUATIVE PHASE',
                protective: 'PROTECTIVE PHASE',
                generative: 'GENERATIVE PHASE',
                implementation: 'IMPLEMENTATION PHASE'
            };
            
            phases.forEach(phase => {
                const phaseEntries = logEntries.filter(e => e.phase === phase);
                if (phaseEntries.length > 0) {
                    content += phaseNames[phase] + '\n';
                    content += '-'.repeat(60) + '\n\n';
                    
                    phaseEntries.forEach(entry => {
                        content += `${entry.modelName}:\n`;
                        content += `${entry.response}\n`;
                        content += `(${entry.timestamp})\n\n`;
                    });
                    
                    content += '\n';
                }
            });
            
            // Add notepad content if not empty
            if (!notepadArea.classList.contains('empty')) {
                content += '=' .repeat(60) + '\n';
                content += 'COMPILED NOTES:\n';
                content += '=' .repeat(60) + '\n\n';
                content += (notepadArea.innerText || notepadArea.textContent) + '\n';
            }
            
            // Create and download file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `decision-session-${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Reset App to Initial State
        function resetApp() {
            // Clear all data
            logEntries = [];
            nextLogId = 1;
            problemDescribed = false;
            problemType = null;
            selectedModel = null;
            currentPhase = 'diagnostic';

            // Clear localStorage
            localStorage.removeItem('mentalModelsLog');

            // Reset UI
            responseInput.value = '';
            notepadArea.innerText = 'Drag log entries here to compile your thinking...';
            notepadArea.classList.add('empty');
            renderLogEntries();

            // Hide problem reference and type selector
            problemReference.classList.remove('visible');
            problemReferenceText.textContent = '';
            problemTypeSelector.classList.remove('visible');
            continueBtn.classList.remove('visible');

            // Hide decision summary
            decisionSummary.classList.remove('visible');
            summaryInput.value = '';

            // Remove split-pane layout
            workAreaContent.classList.remove('split-pane');

            // Hide sections again
            phaseNavigation.classList.remove('revealed');
            modelsSection.classList.remove('revealed');
            workArea.classList.remove('slide-down');

            // Close panels
            closeRightPanel();
            closeLeftPanel();

            // Reorder DOM back to initial state (work area first)
            mainContent.insertBefore(workArea, phaseNavigation);

            // Reset to initial prompt
            showInitialPrompt();
            updatePhaseButtons();
            renderPhaseContent();
        }

        // Clear Current Response (just the textarea)
        function clearCurrentResponse() {
            responseInput.value = '';
            responseInput.focus();
        }

        // Edit Entry
        window.editEntry = function(id) {
            const entry = logEntries.find(e => e.id === id);
            if (!entry) return;

            const newResponse = prompt('Edit your response:', entry.response);
            if (newResponse !== null && newResponse.trim()) {
                entry.response = newResponse.trim();
                entry.timestamp = new Date().toLocaleString() + ' (edited)';
                renderLogEntries();
                saveToLocalStorage();
            }
        };

        // Delete Entry
        window.deleteEntry = function(id) {
            if (confirm('Delete this entry?')) {
                logEntries = logEntries.filter(e => e.id !== id);
                renderLogEntries();
                saveToLocalStorage();
            }
        };

        // Drag and Drop Handlers
        function handleDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', e.target.dataset.entryId);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            notepadArea.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (e.target === notepadArea) {
                notepadArea.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            notepadArea.classList.remove('drag-over');

            const entryId = parseInt(e.dataTransfer.getData('text/plain'));
            const entry = logEntries.find(e => e.id === entryId);
            
            if (entry) {
                const currentContent = notepadArea.classList.contains('empty') ? '' : (notepadArea.innerText || notepadArea.textContent);
                
                // Format the new entry
                const newEntryText = `${entry.modelName}:\n${entry.response}\n${'-'.repeat(60)}\n\n`;
                
                // If notepad is empty, just add the entry
                if (notepadArea.classList.contains('empty')) {
                    notepadArea.innerText = newEntryText.trim();
                } else {
                    // If there's a problem description section, append after the divider
                    if (currentContent.includes('MENTAL MODEL RESPONSES:')) {
                        notepadArea.innerText = currentContent + newEntryText;
                    } else {
                        // Otherwise just append
                        notepadArea.innerText = `${currentContent}\n\n${newEntryText}`;
                    }
                }
                
                notepadArea.classList.remove('empty');
            }
        }

        // Clear Notepad
        function clearNotepad() {
            if (notepadArea.classList.contains('empty')) {
                return;
            }
            
            if (confirm('Clear notepad? This will remove all compiled responses but keep your problem description in the log.')) {
                // If there's a problem description saved, keep it
                if (problemDescribed) {
                    const problemEntry = logEntries.find(e => e.phase === 'initial');
                    if (problemEntry) {
                        notepadArea.innerText = `PROBLEM/DECISION:\n${problemEntry.response}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
                        notepadArea.classList.remove('empty');
                    } else {
                        notepadArea.innerText = 'Drag log entries here to compile your thinking...';
                        notepadArea.classList.add('empty');
                    }
                } else {
                    notepadArea.innerText = 'Drag log entries here to compile your thinking...';
                    notepadArea.classList.add('empty');
                }
            }
        }

        // Copy Notepad
        function copyNotepad() {
            if (notepadArea.classList.contains('empty')) {
                alert('Notepad is empty.');
                return;
            }

            const text = notepadArea.textContent || notepadArea.innerText;
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                const originalBorder = notepadArea.style.borderColor;
                notepadArea.style.borderColor = '#4CAF50';
                setTimeout(() => {
                    notepadArea.style.borderColor = originalBorder;
                }, 500);
            }).catch(() => {
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        // Local Storage
        function saveToLocalStorage() {
            localStorage.setItem('mentalModelsLog', JSON.stringify({
                entries: logEntries,
                nextId: nextLogId
            }));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('mentalModelsLog');
            if (saved) {
                const data = JSON.parse(saved);
                logEntries = data.entries || [];
                nextLogId = data.nextId || 1;

                // Check if problem was already described
                const hasProblemDescription = logEntries.some(e => e.phase === 'initial');
                if (hasProblemDescription) {
                    problemDescribed = true;
                    revealSections();

                    // Restore notepad with problem description
                    const problemEntry = logEntries.find(e => e.phase === 'initial');
                    if (problemEntry) {
                        // Show problem reference banner
                        problemReferenceText.textContent = problemEntry.response;
                        problemReference.classList.add('visible');

                        notepadArea.innerText = `PROBLEM/DECISION:\n${problemEntry.response}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
                        notepadArea.classList.remove('empty');
                    }
                }

                renderLogEntries();

                // Check if decision summary should be shown
                checkShowDecisionSummary();
            }
        }

        // Initialize App
        init();
    </script>
</body>
</html>
