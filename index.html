<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Models Decision Navigator - Untangled Narrative</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --teal: #1B7F92;
            --mauve: #b36278;
            --light-teal: #2a9fb5;
            --light-mauve: #c47a95;
            --cream: #f8f6f3;
            --charcoal: #2a2a2a;
            --warm-white: #fefdfb;
            --shadow-teal: rgba(27, 127, 146, 0.15);
            --shadow-mauve: rgba(179, 98, 120, 0.15);
            --diagnostic-color: #1B7F92;
            --evaluative-color: #4CAF50;
            --protective-color: #b36278;
            --generative-color: #FF9800;
            --implementation-color: #9C27B0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, var(--warm-white) 100%);
            color: var(--charcoal);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
            position: relative;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 0.25rem;
        }

        .header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--charcoal);
            margin-bottom: 0.2rem;
        }

        .header p {
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.65;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            flex: 1;
            margin-right: 60px; /* Space for drawer toggle buttons */
        }

        /* Problem Reference Banner */
        .problem-reference {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.08), white);
            border: 1px solid var(--teal);
            border-left: 4px solid var(--teal);
            border-radius: 8px;
            padding: 1rem;
            display: none;
            margin-bottom: 0.5rem;
        }

        .problem-reference.visible {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .problem-reference-header {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            color: var(--teal);
            margin-bottom: 0.5rem;
            opacity: 0.8;
        }

        .problem-reference-text {
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--charcoal);
            font-weight: 500;
        }

        /* Problem Type Selection */
        .problem-type-selector {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin-bottom: 1rem;
            display: none;
        }

        .problem-type-selector.visible {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        .problem-type-selector h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            color: var(--charcoal);
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .problem-type-selector p {
            font-size: 0.8rem;
            color: var(--charcoal);
            opacity: 0.7;
            margin-bottom: 1rem;
        }

        .problem-types-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .problem-type-card {
            padding: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .problem-type-card:hover {
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
            transform: translateY(-1px);
        }

        .problem-type-card.selected {
            border-color: var(--teal);
            border-width: 2px;
            background: rgba(27, 127, 146, 0.03);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.2);
        }

        .problem-type-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.4rem;
            color: var(--charcoal);
        }

        .problem-type-description {
            font-size: 0.75rem;
            line-height: 1.3;
            color: var(--charcoal);
            opacity: 0.75;
        }

        .continue-btn {
            margin-top: 1rem;
            padding: 0.6rem 1.5rem;
            background: var(--teal);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: none;
        }

        .continue-btn.visible {
            display: inline-block;
        }

        .continue-btn:hover {
            background: var(--light-teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.3);
        }

        /* Toggle Buttons */
        .toggle-buttons {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }

        .toggle-btn {
            background: var(--teal);
            color: white;
            border: none;
            padding: 0.75rem 0.5rem;
            border-radius: 8px 0 0 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            width: 50px;
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 80;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .toggle-btn::before {
            content: '◀';
            font-size: 1rem;
            display: block;
            transition: transform 0.3s ease;
            writing-mode: horizontal-tb;
            text-orientation: upright;
        }

        .toggle-btn:hover {
            background: var(--light-teal);
            transform: translateY(-50%) translateX(-5px);
            box-shadow: -4px 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toggle-btn:hover::before {
            transform: translateX(-3px);
        }

        .toggle-btn.active {
            background: var(--charcoal);
            transform: translateY(-50%) translateX(-5px);
        }

        .toggle-btn.active::before {
            content: '▶';
        }

        /* Drawer Panels */
        .drawer-panel {
            position: fixed;
            top: 0;
            right: -450px;
            width: 450px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
            transition: right 0.3s ease;
            z-index: 90;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .drawer-panel.open {
            right: 0;
        }

        .drawer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            background: var(--cream);
            flex-shrink: 0;
        }

        .drawer-tabs {
            display: flex;
            gap: 0.5rem;
            flex: 1;
        }

        .drawer-tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.6;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .drawer-tab:hover {
            opacity: 0.8;
        }

        .drawer-tab.active {
            opacity: 1;
            border-bottom-color: var(--teal);
            color: var(--teal);
        }

        .drawer-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--charcoal);
            opacity: 0.6;
            transition: opacity 0.3s ease;
            padding: 0;
            line-height: 1;
        }

        .drawer-close:hover {
            opacity: 1;
        }

        .drawer-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 1rem;
        }

        .drawer-section {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .drawer-section.active {
            display: flex;
        }

        /* Phase Navigation */
        .phase-navigation {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 2px solid var(--teal);
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.5s ease, padding 0.5s ease, margin 0.5s ease;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .phase-navigation.revealed {
            max-height: 200px;
            opacity: 1;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .phase-navigation h2 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.7rem;
            color: var(--charcoal);
            margin-bottom: 0.5rem;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            opacity: 0.7;
        }

        .phase-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            justify-content: center;
        }

        .phase-btn {
            flex: 1;
            min-width: 110px;
            padding: 0.5rem 0.6rem;
            border: 2px solid;
            border-radius: 8px;
            background: white;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .phase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .phase-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .phase-btn.diagnostic {
            border-color: var(--diagnostic-color);
            color: var(--diagnostic-color);
        }

        .phase-btn.diagnostic.active {
            background: var(--diagnostic-color);
            color: white;
        }

        .phase-btn.evaluative {
            border-color: var(--evaluative-color);
            color: var(--evaluative-color);
        }

        .phase-btn.evaluative.active {
            background: var(--evaluative-color);
            color: white;
        }

        .phase-btn.protective {
            border-color: var(--protective-color);
            color: var(--protective-color);
        }

        .phase-btn.protective.active {
            background: var(--protective-color);
            color: white;
        }

        .phase-btn.generative {
            border-color: var(--generative-color);
            color: var(--generative-color);
        }

        .phase-btn.generative.active {
            background: var(--generative-color);
            color: white;
        }

        .phase-btn.implementation {
            border-color: var(--implementation-color);
            color: var(--implementation-color);
        }

        .phase-btn.implementation.active {
            background: var(--implementation-color);
            color: white;
        }

        /* Models Section */
        .models-section {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            min-height: 250px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.5s ease 0.3s, opacity 0.5s ease 0.3s, padding 0.5s ease 0.3s;
            padding-top: 0;
            padding-bottom: 0;
        }

        .models-section.revealed {
            max-height: 1000px;
            opacity: 1;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
        }

        .phase-description {
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            border-radius: 6px;
            border-left: 3px solid;
        }

        .phase-description.diagnostic {
            background: rgba(27, 127, 146, 0.08);
            border-color: var(--diagnostic-color);
        }

        .phase-description.evaluative {
            background: rgba(76, 175, 80, 0.08);
            border-color: var(--evaluative-color);
        }

        .phase-description.protective {
            background: rgba(179, 98, 120, 0.08);
            border-color: var(--protective-color);
        }

        .phase-description.generative {
            background: rgba(255, 152, 0, 0.08);
            border-color: var(--generative-color);
        }

        .phase-description.implementation {
            background: rgba(156, 39, 176, 0.08);
            border-color: var(--implementation-color);
        }

        .phase-description h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .phase-description p {
            font-size: 0.75rem;
            line-height: 1.3;
            margin-bottom: 0.15rem;
        }

        .phase-description .core-question {
            font-weight: 600;
            font-style: italic;
            margin-top: 0.25rem;
            opacity: 0.9;
            font-size: 0.75rem;
        }

        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
            gap: 0.6rem;
        }

        .model-card {
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .model-card:hover {
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
            transform: translateY(-1px);
        }

        .model-card.selected {
            border-color: var(--teal);
            border-width: 2px;
            background: rgba(27, 127, 146, 0.03);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.2);
        }

        .model-card.diagnostic.selected {
            border-color: var(--diagnostic-color);
            background: rgba(27, 127, 146, 0.05);
        }

        .model-card.evaluative.selected {
            border-color: var(--evaluative-color);
            background: rgba(76, 175, 80, 0.05);
        }

        .model-card.protective.selected {
            border-color: var(--protective-color);
            background: rgba(179, 98, 120, 0.05);
        }

        .model-card.generative.selected {
            border-color: var(--generative-color);
            background: rgba(255, 152, 0, 0.05);
        }

        .model-card.implementation.selected {
            border-color: var(--implementation-color);
            background: rgba(156, 39, 176, 0.05);
        }

        .model-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            color: var(--charcoal);
            line-height: 1.2;
        }

        .model-description {
            font-size: 0.7rem;
            line-height: 1.25;
            color: var(--charcoal);
            opacity: 0.75;
        }

        /* Work Area */
        .work-area {
            background: white;
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: margin-top 0.5s ease;
            margin-top: 0;
        }

        .work-area.slide-down {
            margin-top: 0;
        }

        .work-area h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.75rem;
            color: var(--charcoal);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            opacity: 0.7;
        }

        .selected-model-display {
            padding: 0.5rem;
            background: var(--cream);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            min-height: 40px;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .selected-model-display.initial {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.1), var(--cream));
            border: 3px solid var(--teal);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 16px rgba(27, 127, 146, 0.2);
        }

        .selected-model-display.initial .instruction-text {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--teal);
            margin-bottom: 0.75rem;
            font-family: 'Montserrat', sans-serif;
            text-align: center;
        }

        .selected-model-display.initial .instruction-subtext {
            font-size: 0.9rem;
            color: var(--charcoal);
            opacity: 0.85;
            line-height: 1.6;
            text-align: center;
        }

        .selected-model-display.empty {
            opacity: 0.5;
            font-style: italic;
        }

        .model-prompt {
            font-weight: 600;
            color: var(--teal);
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
        }

        /* Expanded Model Content Styles */
        .selected-model-display.expanded {
            padding: 1rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .model-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--teal);
        }

        .model-header h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            color: var(--teal);
            margin-bottom: 0.25rem;
        }

        .model-header .model-tagline {
            font-size: 0.85rem;
            color: var(--charcoal);
            opacity: 0.7;
            font-style: italic;
        }

        .model-section {
            margin-bottom: 1rem;
        }

        .model-section-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--mauve);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .model-section-title::before {
            content: '';
            width: 3px;
            height: 14px;
            background: var(--mauve);
            border-radius: 2px;
        }

        .model-explanation {
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--charcoal);
        }

        .model-example {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.08), rgba(27, 127, 146, 0.03));
            border-left: 3px solid var(--teal);
            padding: 0.75rem;
            border-radius: 0 6px 6px 0;
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--charcoal);
        }

        .model-prompts-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .model-prompts-list li {
            position: relative;
            padding: 0.5rem 0.75rem 0.5rem 1.5rem;
            margin-bottom: 0.5rem;
            background: var(--cream);
            border-radius: 6px;
            font-size: 0.8rem;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .model-prompts-list li::before {
            content: '→';
            position: absolute;
            left: 0.5rem;
            color: var(--teal);
            font-weight: bold;
        }

        .model-prompts-list li:hover {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.1), var(--cream));
            border-color: var(--teal);
        }

        .model-prompts-list li.selected-prompt {
            background: linear-gradient(135deg, rgba(27, 127, 146, 0.15), rgba(27, 127, 146, 0.08));
            border-color: var(--teal);
            box-shadow: 0 2px 8px rgba(27, 127, 146, 0.15);
        }

        .model-warnings {
            background: linear-gradient(135deg, rgba(179, 98, 120, 0.08), rgba(179, 98, 120, 0.03));
            border-left: 3px solid var(--mauve);
            padding: 0.75rem;
            border-radius: 0 6px 6px 0;
        }

        .model-warnings ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .model-warnings li {
            font-size: 0.75rem;
            color: var(--charcoal);
            padding: 0.25rem 0;
            padding-left: 1.25rem;
            position: relative;
        }

        .model-warnings li::before {
            content: '⚠';
            position: absolute;
            left: 0;
            color: var(--mauve);
        }

        .model-related {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .model-related-tag {
            background: var(--cream);
            border: 1px solid #ddd;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            color: var(--charcoal);
            opacity: 0.8;
        }

        .prompt-instruction {
            font-size: 0.75rem;
            color: var(--teal);
            opacity: 0.8;
            margin-bottom: 0.5rem;
            font-style: italic;
        }

        textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.6rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.8rem;
            resize: vertical;
            transition: border-color 0.3s ease, min-height 0.3s ease;
            line-height: 1.4;
        }

        textarea.initial-entry {
            min-height: 120px;
            font-size: 0.9rem;
            border-color: var(--teal);
        }

        textarea:focus {
            outline: none;
            border-color: var(--teal);
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--teal);
            color: white;
        }

        .btn-primary:hover {
            background: var(--light-teal);
            box-shadow: 0 1px 4px rgba(27, 127, 146, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--charcoal);
            border: 1px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: var(--cream);
            border-color: var(--mauve);
            color: var(--mauve);
            box-shadow: 0 1px 4px rgba(179, 98, 120, 0.2);
        }

        .btn-warning {
            background: transparent;
            color: #FF9800;
            border: 1px solid #FF9800;
            padding: 0.5rem 0.75rem;
        }

        .btn-warning:hover {
            background: #FF9800;
            color: white;
            box-shadow: 0 1px 4px rgba(255, 152, 0, 0.3);
        }

        /* Sidebar - Now in Drawer */
        .sidebar {
            display: none; /* Hidden - content moved to drawers */
        }

        .decision-log {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .decision-log h3 {
            display: none; /* Header now in drawer-header */
        }

        .log-entries {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .log-entry {
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            cursor: move;
            transition: all 0.2s ease;
            background: white;
        }

        .log-entry:hover {
            border-color: var(--teal);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        .log-entry.diagnostic {
            border-left: 3px solid var(--diagnostic-color);
        }

        .log-entry.evaluative {
            border-left: 3px solid var(--evaluative-color);
        }

        .log-entry.protective {
            border-left: 3px solid var(--protective-color);
        }

        .log-entry.generative {
            border-left: 3px solid var(--generative-color);
        }

        .log-entry.implementation {
            border-left: 3px solid var(--implementation-color);
        }

        .log-entry.initial {
            border-left: 3px solid var(--charcoal);
            background: rgba(42, 42, 42, 0.02);
        }

        .log-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .log-model-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .log-actions {
            display: flex;
            gap: 0.3rem;
        }

        .log-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .log-action-btn:hover {
            opacity: 1;
        }

        .log-content {
            font-size: 0.7rem;
            line-height: 1.3;
            color: var(--charcoal);
            word-wrap: break-word;
        }

        .log-timestamp {
            font-size: 0.65rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        /* Notepad - Now in Drawer */
        .notepad {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .notepad h3 {
            display: none; /* Header now in drawer-header */
        }

        .notepad-area {
            flex: 1;
            padding: 0.6rem;
            border: 2px dashed var(--teal);
            border-radius: 6px;
            background: var(--cream);
            font-size: 0.75rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            min-height: 300px;
            cursor: text;
            outline: none;
        }

        .notepad-area:focus {
            border-color: var(--light-teal);
            border-style: solid;
            background: white;
        }

        .notepad-area.drag-over {
            background: rgba(27, 127, 146, 0.15);
            border-color: var(--light-teal);
        }

        .notepad-area.empty {
            opacity: 0.5;
            font-style: italic;
        }

        .notepad-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .notepad-actions button {
            flex: 1;
            padding: 0.4rem;
            border: 2px solid var(--mauve);
            background: white;
            color: var(--mauve);
            border-radius: 6px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .notepad-actions button:hover {
            background: var(--mauve);
            color: white;
            transform: translateY(-2px);
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 1rem;
            opacity: 0.5;
            font-style: italic;
            font-size: 0.75rem;
        }

        /* Flying Entry Animation */
        @keyframes flyToLog {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(200px, -100px) scale(0.5) rotate(10deg);
                opacity: 0.7;
            }
            100% {
                transform: translate(400px, -200px) scale(0.2) rotate(20deg);
                opacity: 0;
            }
        }

        .flying-entry {
            position: fixed;
            background: white;
            border: 2px solid var(--charcoal);
            border-radius: 8px;
            padding: 0.6rem;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: flyToLog 0.8s ease-out forwards;
        }

        .flying-entry .flying-title {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            margin-bottom: 0.3rem;
            color: var(--charcoal);
        }

        .flying-entry .flying-text {
            font-size: 0.7rem;
            line-height: 1.3;
            color: var(--charcoal);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Scrollbar Styling */
        .log-entries::-webkit-scrollbar,
        .notepad-area::-webkit-scrollbar {
            width: 8px;
        }

        .log-entries::-webkit-scrollbar-track,
        .notepad-area::-webkit-scrollbar-track {
            background: var(--cream);
            border-radius: 4px;
        }

        .log-entries::-webkit-scrollbar-thumb,
        .notepad-area::-webkit-scrollbar-thumb {
            background: var(--teal);
            border-radius: 4px;
        }

        .log-entries::-webkit-scrollbar-thumb:hover,
        .notepad-area::-webkit-scrollbar-thumb:hover {
            background: var(--light-teal);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: 2;
            }
        }

        @media (max-width: 768px) {
            .phase-buttons {
                flex-direction: column;
            }

            .phase-btn {
                min-width: 100%;
            }

            .models-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mental Models Decision Navigator</h1>
            <p>A systematic approach to better decisions through structured thinking</p>
        </div>

        <!-- Toggle Buttons -->
        <div class="toggle-buttons">
            <!-- Single Toggle Button -->
            <button class="toggle-btn" id="drawerToggle">Log & Notes</button>
        </div>

        <!-- Single Tabbed Drawer -->
        <div class="drawer-panel" id="drawer">
            <div class="drawer-header">
                <div class="drawer-tabs">
                    <button class="drawer-tab active" id="logTab">Decision Log</button>
                    <button class="drawer-tab" id="notepadTab">Notepad</button>
                </div>
                <button class="drawer-close" id="drawerClose">&times;</button>
            </div>
            <div class="drawer-content">
                <!-- Decision Log Section -->
                <div class="drawer-section active" id="logSection">
                    <div class="decision-log">
                        <div class="log-entries" id="logEntries">
                            <div class="empty-state">No entries yet. Start by selecting a mental model and responding.</div>
                        </div>
                    </div>
                </div>
                
                <!-- Notepad Section -->
                <div class="drawer-section" id="notepadSection">
                    <div class="notepad">
                        <div class="notepad-area empty" id="notepadArea" contenteditable="true">
                            Drag log entries here to compile your thinking...
                        </div>
                        <div class="notepad-actions">
                            <button id="clearNotepad">Clear</button>
                            <button id="copyNotepad">Copy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- Problem Reference Banner - shows after problem is described -->
            <div class="problem-reference" id="problemReference">
                <div class="problem-reference-header">Your Decision / Problem</div>
                <div class="problem-reference-text" id="problemReferenceText"></div>
            </div>

            <!-- Problem Type Selector - shows after problem description, before models -->
            <div class="problem-type-selector" id="problemTypeSelector">
                <h3>What type of problem is this?</h3>
                <p>Selecting a problem type will show you the most relevant mental models for your situation.</p>
                <div class="problem-types-grid" id="problemTypesGrid">
                    <!-- Problem types will be populated by JavaScript -->
                </div>
                <button class="continue-btn" id="continueBtn">Continue with Selected Type</button>
            </div>

            <!-- Work Area - appears first, at top -->
            <div class="work-area">
                <h3>Your Response</h3>
                <div class="selected-model-display empty" id="selectedModelDisplay">
                    Select a mental model to begin...
                </div>
                <textarea id="responseInput" placeholder="Apply this mental model to your situation..."></textarea>
                <div class="action-buttons">
                    <button class="btn btn-primary" id="saveBtn">Add to Log</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear Answer</button>
                    <button class="btn btn-warning" id="startOverBtn">Start Over</button>
                </div>
            </div>

            <!-- Phase Navigation - hidden initially -->
            <div class="phase-navigation">
                <h2>Decision-Making Sequence</h2>
                <div class="phase-buttons">
                    <button class="phase-btn diagnostic active" data-phase="diagnostic">
                        1. Diagnose
                    </button>
                    <button class="phase-btn evaluative" data-phase="evaluative">
                        2. Evaluate
                    </button>
                    <button class="phase-btn protective" data-phase="protective">
                        3. Protect
                    </button>
                    <button class="phase-btn generative" data-phase="generative">
                        4. Generate
                    </button>
                    <button class="phase-btn implementation" data-phase="implementation">
                        5. Implement
                    </button>
                </div>
            </div>

            <!-- Models Section - hidden initially -->
            <div class="models-section">
                <div class="phase-description diagnostic" id="phaseDescription">
                    <h3>Diagnostic Models</h3>
                    <p><strong>Purpose:</strong> Understand what's actually happening before making decisions</p>
                    <p class="core-question">What's the true nature of this situation?</p>
                </div>
                <div class="models-grid" id="modelsGrid">
                    <!-- Models will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mental Models Data Structure
        const mentalModelsData = {
            diagnostic: {
                title: "Diagnostic Models",
                purpose: "Understand what's actually happening before making decisions",
                coreQuestion: "What's the true nature of this situation?",
                whenToUse: "At the beginning of any decision process, when confused or stuck, when conventional explanations don't fit the evidence.",
                models: [
                    {
                        name: "Circle of Competence",
                        description: "Know what you know vs. what you assume",
                        explanation: "The Circle of Competence, popularized by Warren Buffett and Charlie Munger, helps you identify the boundaries of your true knowledge. Inside your circle are areas where you have genuine expertise through study, experience, or training. Outside are areas where you may have opinions but lack deep understanding. The key insight is that the size of your circle matters less than knowing its boundaries.",
                        example: "A successful software engineer is asked to evaluate a commercial real estate investment. Despite being intelligent and analytical, real estate requires understanding of local markets, zoning laws, property management, and financing structures they've never studied. Their technical success doesn't transfer. Recognizing this, they either decline, find an expert partner, or invest significant time learning before deciding.",
                        prompts: [
                            "What specific expertise or experience do you have that's directly relevant to this situation?",
                            "Where are you relying on assumptions, analogies, or 'common sense' rather than verified knowledge?",
                            "If you had to teach someone the fundamentals of this domain, could you? What gaps would appear?",
                            "Who has genuine expertise here that you could consult or defer to?"
                        ],
                        warnings: [
                            "Confidence is not competence—feeling certain doesn't mean you're right",
                            "Success in one domain doesn't automatically transfer to another",
                            "The Dunning-Kruger effect: those with limited knowledge often overestimate their competence"
                        ],
                        relatedModels: ["First Principles", "Confirmation Bias Recognition"]
                    },
                    {
                        name: "Occam's Razor",
                        description: "The simplest explanation is usually correct",
                        explanation: "Occam's Razor (also called the principle of parsimony) states that when you have competing explanations for something, the one with the fewest assumptions is usually correct. This doesn't mean the simplest explanation is always right, but that you shouldn't add complexity without evidence. Each additional assumption multiplies the chances of error.",
                        example: "Your laptop won't turn on. You could theorize: (A) the battery is dead, or (B) a power surge damaged the motherboard, which triggered a firmware corruption, which disabled the power button circuit. Occam's Razor says try charging the battery first. Don't assume a complex chain of failures when a simple explanation fits.",
                        prompts: [
                            "What is the simplest explanation that accounts for all the evidence you're seeing?",
                            "How many assumptions does your current theory require? Can you list them?",
                            "Are you adding complexity because of evidence, or because of anxiety, ego, or narrative appeal?",
                            "What would you need to see to rule out the simpler explanation?"
                        ],
                        warnings: [
                            "Simple doesn't mean easy or obvious—it means fewer moving parts",
                            "Don't oversimplify: the explanation must still fit all the evidence",
                            "Sometimes reality is genuinely complex; Occam's Razor is a starting point, not a conclusion"
                        ],
                        relatedModels: ["First Principles", "Root Cause Analysis"]
                    },
                    {
                        name: "First Principles",
                        description: "Break down to fundamental truths",
                        explanation: "First Principles thinking means breaking down a problem into its most basic, foundational truths—things you know to be true independent of convention, assumption, or analogy—and then building up from there. Instead of reasoning by analogy ('this is how it's always been done'), you ask 'what do we know for certain?' This approach, used by scientists and innovators from Aristotle to Elon Musk, often reveals that conventional limits are actually just conventions.",
                        example: "When SpaceX started, rockets cost $65 million. Instead of accepting this, Musk asked: what are rockets made of? Aluminum, titanium, copper, carbon fiber. What do those materials cost on the commodity market? About 2% of the rocket price. The rest was inefficiency, tradition, and markup. By building from first principles rather than industry convention, SpaceX cut costs by 90%.",
                        prompts: [
                            "What are the fundamental truths or facts in this situation that you know to be true?",
                            "What assumptions are you inheriting from convention, tradition, or 'how things are done'?",
                            "If you had to explain this problem to someone with no context, what are the irreducible components?",
                            "What would you do differently if you were starting from scratch with no constraints?"
                        ],
                        warnings: [
                            "First principles thinking is mentally taxing—don't use it for every minor decision",
                            "Be careful not to dismiss useful conventions just because they're conventional",
                            "You still need domain knowledge to identify what the true fundamentals are"
                        ],
                        relatedModels: ["Circle of Competence", "Root Cause Analysis", "Systems Thinking"]
                    },
                    {
                        name: "Confirmation Bias Recognition",
                        description: "Challenge your assumptions",
                        explanation: "Confirmation bias is our tendency to search for, interpret, favor, and recall information in a way that confirms our existing beliefs. We literally see what we expect to see. This isn't a character flaw—it's how human cognition works. The only defense is actively seeking disconfirmation: looking for evidence that proves you wrong, not right. Scientists call this 'falsification' and it's the foundation of the scientific method.",
                        example: "A manager believes a team member is unmotivated. They start noticing every time the person arrives late or seems disengaged, while overlooking the quality work produced and the personal challenges the person may be facing. Each observation 'confirms' their belief. To counter this, they should actively look for evidence of motivation: projects completed, problems solved, ideas contributed.",
                        prompts: [
                            "What do you believe about this situation? State it clearly as a hypothesis.",
                            "What evidence would prove your belief WRONG? Have you looked for it?",
                            "Who disagrees with your view? What's the strongest version of their argument?",
                            "If you woke up tomorrow and discovered you were completely wrong about this, what would be the first clue?"
                        ],
                        warnings: [
                            "Seeking disconfirming evidence feels uncomfortable—that discomfort is a feature, not a bug",
                            "You can't eliminate confirmation bias, only manage it through deliberate practice",
                            "Being aware of the bias doesn't automatically protect you from it"
                        ],
                        relatedModels: ["Circle of Competence", "First Principles", "Inversion"]
                    },
                    {
                        name: "Root Cause Analysis",
                        description: "Find underlying causes, not symptoms",
                        explanation: "Root Cause Analysis is a systematic process of identifying the fundamental reason why a problem occurred, rather than just addressing surface symptoms. The most common technique is '5 Whys'—asking 'why' repeatedly until you reach a cause that, if addressed, would prevent recurrence. Treating symptoms provides temporary relief; treating root causes provides lasting solutions.",
                        example: "A website keeps crashing. Symptom: server runs out of memory. Why? Too many database connections. Why? Connections aren't being closed properly. Why? Developers aren't following the connection pooling standard. Why? The standard isn't documented or enforced. Why? No code review process exists. Root cause: missing development process, not a technical bug. Fix the process, fix the problem permanently.",
                        prompts: [
                            "What is the immediate problem? Now ask: WHY is this happening?",
                            "Take your answer and ask WHY again. Repeat at least 5 times.",
                            "At what level of 'why' do you find something you can actually change or control?",
                            "If you fixed this root cause, would the original problem be impossible or unlikely to recur?"
                        ],
                        warnings: [
                            "Don't stop at the first 'why'—surface causes are rarely root causes",
                            "There may be multiple root causes; don't assume there's only one",
                            "Sometimes you need to treat symptoms urgently while working on root causes in parallel"
                        ],
                        relatedModels: ["First Principles", "Systems Thinking", "Occam's Razor"]
                    },
                    {
                        name: "Systems Thinking",
                        description: "See how parts interact",
                        explanation: "Systems Thinking is a holistic approach that focuses on how components interrelate and work together over time within larger systems. Instead of analyzing parts in isolation, you examine feedback loops, delays, unintended consequences, and emergent behaviors. Many problems persist because solutions address components without understanding the system dynamics that created and maintain the problem.",
                        example: "A city tries to reduce traffic by adding highway lanes. Initially traffic improves, but within two years it's worse than before. Why? The system responded: easier commutes attracted more drivers, developers built more suburbs, and the induced demand filled the new capacity. A systems view would have predicted this and suggested alternatives like congestion pricing or transit investment that change the feedback loops.",
                        prompts: [
                            "What are all the components or stakeholders in this system? How are they connected?",
                            "What feedback loops exist? Are they reinforcing (amplifying) or balancing (stabilizing)?",
                            "What are the delays in this system? How long before actions produce effects?",
                            "If you made your proposed change, what secondary effects might ripple through the system?"
                        ],
                        warnings: [
                            "Systems are often counter-intuitive: obvious solutions can backfire",
                            "Delays between action and effect make it hard to learn from feedback",
                            "You can't understand a system just by understanding its parts—emergence is real"
                        ],
                        relatedModels: ["Second-Order Thinking", "Root Cause Analysis", "First Principles"]
                    }
                ]
            },
            evaluative: {
                title: "Evaluative Models",
                purpose: "Weigh options and determine what matters most",
                coreQuestion: "How do these alternatives compare?",
                whenToUse: "When comparing alternatives, allocating resources, prioritizing actions, or determining trade-offs.",
                models: [
                    {
                        name: "Opportunity Cost",
                        description: "What you give up for this choice",
                        prompt: "What are you trading for this choice? What are you giving up?"
                    },
                    {
                        name: "Incentives",
                        description: "What drives the behavior",
                        prompt: "What drives the behavior you're seeing? Follow the incentives."
                    },
                    {
                        name: "Second-Order Thinking",
                        description: "Consider downstream consequences",
                        prompt: "What are the downstream consequences? Then what? And then what?"
                    },
                    {
                        name: "Cost-Benefit Analysis",
                        description: "Does the gain justify the cost",
                        prompt: "Does the gain justify the investment? List all costs and benefits."
                    },
                    {
                        name: "Expected Value",
                        description: "Probability-weighted outcomes",
                        prompt: "What's the probability-weighted outcome? (Probability × Outcome for each scenario)"
                    },
                    {
                        name: "Pareto Principle (80/20)",
                        description: "Find disproportionate impact",
                        prompt: "Where is the disproportionate impact? What 20% creates 80% of results?"
                    },
                    {
                        name: "Satisficing vs. Optimizing",
                        description: "Good enough vs. perfect",
                        prompt: "Is 'good enough' better than 'perfect'? When does more searching hurt?"
                    }
                ]
            },
            protective: {
                title: "Protective Models",
                purpose: "Reduce risk and avoid disaster",
                coreQuestion: "How do I prevent failure?",
                whenToUse: "Before major commitments, when downside is severe, in high-uncertainty situations, when building systems or strategies.",
                models: [
                    {
                        name: "Margin of Safety",
                        description: "Build in extra buffer capacity",
                        prompt: "What buffer do I need? Build in extra capacity beyond requirements."
                    },
                    {
                        name: "Inversion",
                        description: "Ask how to fail, then avoid that",
                        prompt: "What guarantees failure? Instead of asking how to succeed, ask how to fail—then avoid that."
                    },
                    {
                        name: "Reversible vs. Irreversible Decisions",
                        description: "Can you undo this decision",
                        prompt: "How permanent is this? Can I undo it? How much caution is warranted?"
                    },
                    {
                        name: "Pre-mortem",
                        description: "Identify failure modes in advance",
                        prompt: "If this failed spectacularly, what would have caused it? Identify failure modes in advance."
                    },
                    {
                        name: "Antifragility",
                        description: "Benefit from volatility",
                        prompt: "How can I benefit from volatility? What gets stronger under stress?"
                    },
                    {
                        name: "Redundancy",
                        description: "Prevent single points of failure",
                        prompt: "What backup systems prevent single points of failure? Where do I need duplicates?"
                    },
                    {
                        name: "Precautionary Principle",
                        description: "When unknown risks are too great",
                        prompt: "When is caution warranted despite uncertainty? When are unknown risks too great?"
                    }
                ]
            },
            generative: {
                title: "Generative Models",
                purpose: "Create new possibilities and novel solutions",
                coreQuestion: "What options haven't I considered?",
                whenToUse: "When stuck with unsatisfactory options, when innovation is needed, when breaking into new markets or categories.",
                models: [
                    {
                        name: "First Principles (Generative)",
                        description: "Rebuild from scratch differently",
                        prompt: "Can we rebuild this differently from scratch? Ignore 'how it's always been done.'"
                    },
                    {
                        name: "Lateral Thinking",
                        description: "Approach from different angle",
                        prompt: "What if we approached from a different angle? What's an indirect path?"
                    },
                    {
                        name: "Combinatorial Thinking",
                        description: "Merge X and Y for new combinations",
                        prompt: "What happens if we merge X and Y? What new combinations are possible?"
                    },
                    {
                        name: "Constraint Removal",
                        description: "Challenge assumed limitations",
                        prompt: "What if this limitation didn't exist? Challenge your assumptions about what's fixed."
                    },
                    {
                        name: "Analogical Thinking",
                        description: "Learn from different domains",
                        prompt: "How is this like something else entirely? What can we learn from different domains?"
                    },
                    {
                        name: "Reframing",
                        description: "Define the problem differently",
                        prompt: "What changes if we define the problem differently? Is there another way to see this?"
                    },
                    {
                        name: "Blue Ocean Strategy",
                        description: "Find uncontested market space",
                        prompt: "Where is the uncontested market space? How can we make competition irrelevant?"
                    }
                ]
            },
            implementation: {
                title: "Implementation Models",
                purpose: "Move from decision to effective action",
                coreQuestion: "How do I actually execute this?",
                whenToUse: "After deciding what to do, when planning execution, when building sustainable practices.",
                models: [
                    {
                        name: "Minimum Viable Product (MVP)",
                        description: "Smallest testable version",
                        prompt: "What's the smallest testable version? Start with the minimum that provides learning."
                    },
                    {
                        name: "Feedback Loops",
                        description: "Track if this is working",
                        prompt: "How do I know if this is working? What metrics tell me I'm on track?"
                    },
                    {
                        name: "Compound Interest",
                        description: "Small actions, exponential results",
                        prompt: "What small thing, repeated, creates exponential results? What compounds over time?"
                    },
                    {
                        name: "Leverage",
                        description: "Small effort, big impact",
                        prompt: "Where does small effort create disproportionate impact? Find the highest-leverage activities."
                    },
                    {
                        name: "Critical Path",
                        description: "Sequence and dependencies",
                        prompt: "What must happen in what sequence? Identify dependencies and bottlenecks."
                    },
                    {
                        name: "80/20 Action",
                        description: "Focus on highest-impact actions",
                        prompt: "What 20% of actions drive 80% of results? Focus ruthlessly."
                    },
                    {
                        name: "Habit Stacking",
                        description: "Link to established routines",
                        prompt: "How do I attach new behaviors to existing ones? Link to established routines."
                    }
                ]
            }
        };

        // Problem Types and Their Relevant Models
        const problemTypes = {
            strategic: {
                name: "Strategic Decision",
                description: "Long-term direction, business strategy, major pivots, market positioning",
                models: {
                    diagnostic: ["First Principles", "Systems Thinking", "Confirmation Bias Recognition"],
                    evaluative: ["Second-Order Thinking", "Opportunity Cost", "Expected Value", "Pareto Principle (80/20)"],
                    protective: ["Pre-mortem", "Reversible vs. Irreversible Decisions", "Inversion"],
                    generative: ["First Principles (Generative)", "Blue Ocean Strategy", "Reframing", "Constraint Removal"],
                    implementation: ["Critical Path", "Feedback Loops", "80/20 Action"]
                }
            },
            operational: {
                name: "Operational Problem",
                description: "Process improvement, efficiency, workflows, resource allocation, team coordination",
                models: {
                    diagnostic: ["Root Cause Analysis", "Systems Thinking", "Occam's Razor"],
                    evaluative: ["Pareto Principle (80/20)", "Cost-Benefit Analysis", "Opportunity Cost"],
                    protective: ["Margin of Safety", "Redundancy", "Inversion"],
                    generative: ["Constraint Removal", "Combinatorial Thinking", "Lateral Thinking"],
                    implementation: ["Critical Path", "Leverage", "80/20 Action", "Feedback Loops"]
                }
            },
            interpersonal: {
                name: "People/Team Issue",
                description: "Conflict resolution, hiring, firing, team dynamics, communication, leadership",
                models: {
                    diagnostic: ["Circle of Competence", "Confirmation Bias Recognition", "Root Cause Analysis"],
                    evaluative: ["Incentives", "Second-Order Thinking", "Opportunity Cost"],
                    protective: ["Pre-mortem", "Reversible vs. Irreversible Decisions", "Margin of Safety"],
                    generative: ["Reframing", "Lateral Thinking", "Analogical Thinking"],
                    implementation: ["Feedback Loops", "Habit Stacking", "Minimum Viable Product (MVP)"]
                }
            },
            technical: {
                name: "Technical/Analytical Problem",
                description: "Debugging, troubleshooting, data analysis, system design, technical architecture",
                models: {
                    diagnostic: ["Occam's Razor", "Root Cause Analysis", "First Principles", "Systems Thinking"],
                    evaluative: ["Cost-Benefit Analysis", "Expected Value", "Satisficing vs. Optimizing"],
                    protective: ["Margin of Safety", "Redundancy", "Pre-mortem", "Antifragility"],
                    generative: ["First Principles (Generative)", "Constraint Removal", "Combinatorial Thinking"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Critical Path"]
                }
            },
            personal: {
                name: "Personal Decision",
                description: "Career change, major purchase, relationship, lifestyle, health, financial planning",
                models: {
                    diagnostic: ["Circle of Competence", "Confirmation Bias Recognition", "First Principles"],
                    evaluative: ["Opportunity Cost", "Second-Order Thinking", "Expected Value", "Satisficing vs. Optimizing"],
                    protective: ["Reversible vs. Irreversible Decisions", "Pre-mortem", "Inversion", "Margin of Safety"],
                    generative: ["Reframing", "Constraint Removal", "Lateral Thinking"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Habit Stacking", "Compound Interest"]
                }
            },
            creative: {
                name: "Innovation/Creative Challenge",
                description: "New product, creative project, innovation, breaking into new markets, differentiation",
                models: {
                    diagnostic: ["First Principles", "Confirmation Bias Recognition", "Systems Thinking"],
                    evaluative: ["Opportunity Cost", "Second-Order Thinking", "Pareto Principle (80/20)"],
                    protective: ["Reversible vs. Irreversible Decisions", "Antifragility", "Pre-mortem"],
                    generative: ["First Principles (Generative)", "Blue Ocean Strategy", "Combinatorial Thinking", "Lateral Thinking", "Constraint Removal", "Analogical Thinking", "Reframing"],
                    implementation: ["Minimum Viable Product (MVP)", "Feedback Loops", "Leverage"]
                }
            }
        };

        // State Management
        let currentPhase = 'diagnostic';
        let selectedModel = null;
        let logEntries = [];
        let nextLogId = 1;
        let problemDescribed = false;
        let problemType = null;

        // DOM Elements
        const container = document.querySelector('.container');
        const problemReference = document.getElementById('problemReference');
        const problemReferenceText = document.getElementById('problemReferenceText');
        const problemTypeSelector = document.getElementById('problemTypeSelector');
        const problemTypesGrid = document.getElementById('problemTypesGrid');
        const continueBtn = document.getElementById('continueBtn');
        const phaseButtons = document.querySelectorAll('.phase-btn');
        const phaseNavigation = document.querySelector('.phase-navigation');
        const modelsSection = document.querySelector('.models-section');
        const workArea = document.querySelector('.work-area');
        const mainContent = document.querySelector('.main-content');
        const modelsGrid = document.getElementById('modelsGrid');
        const phaseDescription = document.getElementById('phaseDescription');
        const selectedModelDisplay = document.getElementById('selectedModelDisplay');
        const responseInput = document.getElementById('responseInput');
        const saveBtn = document.getElementById('saveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const logEntriesContainer = document.getElementById('logEntries');
        const notepadArea = document.getElementById('notepadArea');
        const clearNotepadBtn = document.getElementById('clearNotepad');
        const copyNotepadBtn = document.getElementById('copyNotepad');
        
        // Drawer elements
        const logToggle = document.getElementById('logToggle');
        const notepadToggle = document.getElementById('notepadToggle');
        const drawer = document.getElementById('drawer');
        const drawerToggle = document.getElementById('drawerToggle');
        const drawerClose = document.getElementById('drawerClose');
        const logTab = document.getElementById('logTab');
        const notepadTab = document.getElementById('notepadTab');
        const logSection = document.getElementById('logSection');
        const notepadSection = document.getElementById('notepadSection');

        // Render Problem Type Selector
        function renderProblemTypeSelector() {
            problemTypesGrid.innerHTML = '';
            
            Object.keys(problemTypes).forEach(typeKey => {
                const type = problemTypes[typeKey];
                const card = document.createElement('div');
                card.className = 'problem-type-card';
                card.dataset.typeKey = typeKey;
                card.innerHTML = `
                    <div class="problem-type-name">${type.name}</div>
                    <div class="problem-type-description">${type.description}</div>
                `;
                card.addEventListener('click', () => selectProblemType(typeKey, card));
                problemTypesGrid.appendChild(card);
            });
        }

        // Select Problem Type
        function selectProblemType(typeKey, card) {
            // Clear previous selection
            document.querySelectorAll('.problem-type-card').forEach(c => c.classList.remove('selected'));
            
            // Set new selection
            card.classList.add('selected');
            problemType = typeKey;
            
            // Show continue button
            continueBtn.classList.add('visible');
        }

        // Continue After Problem Type Selection
        function continueToProblemSolving() {
            // Hide problem type selector
            problemTypeSelector.classList.remove('visible');
            
            // Reveal the decision-making sections with filtered models
            setTimeout(() => {
                revealSections();
            }, 300);
        }

        // Initialize
        function init() {
            showInitialPrompt();
            renderPhaseContent();
            setupEventListeners();
            setupDrawers();
            loadFromLocalStorage();
        }

        // Show Initial Prompt
        function showInitialPrompt() {
            selectedModelDisplay.className = 'selected-model-display initial';
            selectedModelDisplay.innerHTML = `
                <div class="instruction-text">Welcome! Let's start with your decision or problem.</div>
                <div class="instruction-subtext">Before exploring mental models, describe the situation you're facing. What decision do you need to make? What problem are you trying to solve?</div>
            `;
            responseInput.placeholder = "Describe your decision or problem here...";
            responseInput.classList.add('initial-entry');
            saveBtn.textContent = 'Add to Log';
        }

        // Setup Drawer Controls
        function setupDrawers() {
            drawerToggle.addEventListener('click', toggleDrawer);
            drawerClose.addEventListener('click', closeDrawer);
            logTab.addEventListener('click', () => switchTab('log'));
            notepadTab.addEventListener('click', () => switchTab('notepad'));
        }

        function toggleDrawer() {
            drawer.classList.toggle('open');
            drawerToggle.classList.toggle('active');
        }

        function closeDrawer() {
            drawer.classList.remove('open');
            drawerToggle.classList.remove('active');
        }

        function switchTab(tab) {
            if (tab === 'log') {
                logTab.classList.add('active');
                notepadTab.classList.remove('active');
                logSection.classList.add('active');
                notepadSection.classList.remove('active');
            } else {
                notepadTab.classList.add('active');
                logTab.classList.remove('active');
                notepadSection.classList.add('active');
                logSection.classList.remove('active');
            }
        }

        // Setup Event Listeners
        function setupEventListeners() {
            phaseButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    currentPhase = btn.dataset.phase;
                    updatePhaseButtons();
                    renderPhaseContent();
                    clearSelection();
                });
            });

            saveBtn.addEventListener('click', saveToLog);
            clearBtn.addEventListener('click', clearCurrentResponse);
            startOverBtn.addEventListener('click', startOver);
            continueBtn.addEventListener('click', continueToProblemSolving);
            clearNotepadBtn.addEventListener('click', clearNotepad);
            copyNotepadBtn.addEventListener('click', copyNotepad);

            // Drag and drop for notepad
            notepadArea.addEventListener('dragover', handleDragOver);
            notepadArea.addEventListener('drop', handleDrop);
            notepadArea.addEventListener('dragleave', handleDragLeave);
        }

        // Update Phase Buttons
        function updatePhaseButtons() {
            phaseButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.phase === currentPhase);
            });
        }

        // Render Phase Content
        function renderPhaseContent() {
            const phaseData = mentalModelsData[currentPhase];
            
            // Update phase description
            phaseDescription.className = `phase-description ${currentPhase}`;
            phaseDescription.innerHTML = `
                <h3>${phaseData.title}</h3>
                <p><strong>Purpose:</strong> ${phaseData.purpose}</p>
                <p class="core-question">${phaseData.coreQuestion}</p>
            `;

            // Filter models based on problem type
            let modelsToShow = phaseData.models;
            if (problemType && problemTypes[problemType]) {
                const relevantModelNames = problemTypes[problemType].models[currentPhase];
                if (relevantModelNames) {
                    modelsToShow = phaseData.models.filter(model => 
                        relevantModelNames.includes(model.name)
                    );
                }
            }

            // Render models
            modelsGrid.innerHTML = '';
            modelsToShow.forEach((model, index) => {
                const modelCard = document.createElement('div');
                modelCard.className = `model-card ${currentPhase}`;
                modelCard.dataset.modelIndex = index;
                modelCard.innerHTML = `
                    <div class="model-name">${model.name}</div>
                    <div class="model-description">${model.description}</div>
                `;
                modelCard.addEventListener('click', () => selectModel(model, modelCard));
                modelsGrid.appendChild(modelCard);
            });
            
            // Show message if no models match
            if (modelsToShow.length === 0) {
                modelsGrid.innerHTML = '<div class="empty-state">No models match this problem type for this phase. Try another phase or problem type.</div>';
            }
        }

        // Select Model
        function selectModel(model, card) {
            // If problem hasn't been described yet, save it first
            if (!problemDescribed && responseInput.value.trim()) {
                saveProblemDescription();
                return; // Let the save process complete
            }

            // Clear previous selection
            document.querySelectorAll('.model-card').forEach(c => c.classList.remove('selected'));

            // Set new selection
            card.classList.add('selected');
            selectedModel = { ...model, phase: currentPhase };

            // Check if this model has expanded content
            if (model.prompts && model.explanation) {
                // Render expanded model display
                selectedModelDisplay.className = 'selected-model-display expanded';
                selectedModelDisplay.innerHTML = renderExpandedModel(model);

                // Set up prompt selection handlers
                setupPromptSelection();
            } else {
                // Fallback to simple display for models not yet expanded
                selectedModelDisplay.className = 'selected-model-display';
                selectedModelDisplay.innerHTML = `
                    <div class="model-prompt"><strong>${model.name}</strong></div>
                    <div>${model.prompt}</div>
                `;
            }

            // Reset placeholder and button for model response
            responseInput.placeholder = "Apply this mental model to your situation...";
            responseInput.classList.remove('initial-entry');
            saveBtn.textContent = 'Add to Log';

            // Focus textarea
            responseInput.focus();
        }

        // Render expanded model content
        function renderExpandedModel(model) {
            const promptsHtml = model.prompts.map((prompt, index) =>
                `<li data-prompt="${escapeHtml(prompt)}">${prompt}</li>`
            ).join('');

            const warningsHtml = model.warnings ? model.warnings.map(w =>
                `<li>${w}</li>`
            ).join('') : '';

            const relatedHtml = model.relatedModels ? model.relatedModels.map(r =>
                `<span class="model-related-tag">${r}</span>`
            ).join('') : '';

            return `
                <div class="model-header">
                    <h3>${model.name}</h3>
                    <div class="model-tagline">${model.description}</div>
                </div>

                <div class="model-section">
                    <div class="model-section-title">What It Is</div>
                    <div class="model-explanation">${model.explanation}</div>
                </div>

                <div class="model-section">
                    <div class="model-section-title">Example</div>
                    <div class="model-example">${model.example}</div>
                </div>

                <div class="model-section">
                    <div class="model-section-title">Questions to Ask</div>
                    <div class="prompt-instruction">Click a question to use it as your prompt:</div>
                    <ul class="model-prompts-list">
                        ${promptsHtml}
                    </ul>
                </div>

                ${model.warnings ? `
                <div class="model-section">
                    <div class="model-section-title">Watch Out For</div>
                    <div class="model-warnings">
                        <ul>${warningsHtml}</ul>
                    </div>
                </div>
                ` : ''}

                ${model.relatedModels ? `
                <div class="model-section">
                    <div class="model-section-title">Related Models</div>
                    <div class="model-related">${relatedHtml}</div>
                </div>
                ` : ''}
            `;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Set up click handlers for prompt selection
        function setupPromptSelection() {
            const promptItems = document.querySelectorAll('.model-prompts-list li');
            promptItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Remove selection from others
                    promptItems.forEach(p => p.classList.remove('selected-prompt'));
                    // Add selection to clicked
                    this.classList.add('selected-prompt');

                    // Update the selected model's active prompt
                    const selectedPrompt = this.getAttribute('data-prompt');
                    if (selectedModel) {
                        selectedModel.activePrompt = selectedPrompt;
                    }

                    // Update placeholder to show the selected question
                    responseInput.placeholder = `Respond to: "${selectedPrompt.substring(0, 60)}${selectedPrompt.length > 60 ? '...' : ''}"`;
                    responseInput.focus();
                });
            });

            // Auto-select first prompt
            if (promptItems.length > 0) {
                promptItems[0].click();
            }
        }

        // Create Flying Entry Animation
        function createFlyingEntry(text) {
            // Get the position of the work area
            const workArea = document.querySelector('.work-area');
            const workRect = workArea.getBoundingClientRect();
            
            // Create the flying element
            const flyingEl = document.createElement('div');
            flyingEl.className = 'flying-entry';
            flyingEl.style.left = `${workRect.left}px`;
            flyingEl.style.top = `${workRect.top + 100}px`;
            flyingEl.innerHTML = `
                <div class="flying-title">Problem Description</div>
                <div class="flying-text">${text}</div>
            `;
            
            document.body.appendChild(flyingEl);
            
            // Remove after animation completes
            setTimeout(() => {
                flyingEl.remove();
            }, 800);
        }

        // Reveal Sections
        function revealSections() {
            // Move phase navigation and models section before work area
            mainContent.insertBefore(phaseNavigation, workArea);
            mainContent.insertBefore(modelsSection, workArea);
            
            // Reveal phase navigation first
            phaseNavigation.classList.add('revealed');
            
            // Then reveal models section with a slight delay
            setTimeout(() => {
                modelsSection.classList.add('revealed');
            }, 100);
            
            // Slide work area down
            setTimeout(() => {
                workArea.classList.add('slide-down');
            }, 200);
        }

        // Save Problem Description
        function saveProblemDescription() {
            const description = responseInput.value.trim();
            if (!description) return;

            // Create flying animation
            createFlyingEntry(description);

            const entry = {
                id: nextLogId++,
                phase: 'initial',
                modelName: 'Problem Description',
                modelPrompt: 'What decision or problem are you trying to solve?',
                response: description,
                timestamp: new Date().toLocaleString()
            };

            logEntries.unshift(entry);
            problemDescribed = true;
            
            // Show problem reference banner
            problemReferenceText.textContent = description;
            setTimeout(() => {
                problemReference.classList.add('visible');
            }, 100);
            
            // Delay log rendering and drawer opening to sync with animation
            setTimeout(() => {
                renderLogEntries();
                saveToLocalStorage();
                
                // Open drawer and show log tab
                drawer.classList.add('open');
                drawerToggle.classList.add('active');
                switchTab('log');
            }, 400);
            
            // Add problem description to notepad automatically
            notepadArea.innerText = `PROBLEM/DECISION:\n${description}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
            notepadArea.classList.remove('empty');
            
            // Show problem type selector after brief delay
            setTimeout(() => {
                problemTypeSelector.classList.add('visible');
                renderProblemTypeSelector();
            }, 900);
            
            // Clear the textarea and reset styling
            responseInput.value = '';
            responseInput.classList.remove('initial-entry');
            saveBtn.textContent = 'Add to Log';
        }

        // Clear Selection
        function clearSelection() {
            selectedModel = null;
            document.querySelectorAll('.model-card').forEach(c => c.classList.remove('selected'));
            
            if (!problemDescribed) {
                showInitialPrompt();
            } else {
                selectedModelDisplay.className = 'selected-model-display empty';
                selectedModelDisplay.innerHTML = 'Select a mental model to continue...';
                responseInput.placeholder = "Apply this mental model to your situation...";
            }
        }

        // Save to Log
        function saveToLog() {
            // If we haven't described the problem yet, save the problem description
            if (!problemDescribed) {
                if (!responseInput.value.trim()) {
                    alert('Please describe your decision or problem before continuing.');
                    return;
                }
                saveProblemDescription();
                return;
            }
            
            // Otherwise, save a mental model response
            if (!selectedModel || !responseInput.value.trim()) {
                alert('Please select a mental model and enter your response.');
                return;
            }

            const entry = {
                id: nextLogId++,
                phase: selectedModel.phase,
                modelName: selectedModel.name,
                modelPrompt: selectedModel.activePrompt || selectedModel.prompt,
                response: responseInput.value.trim(),
                timestamp: new Date().toLocaleString()
            };

            logEntries.unshift(entry);
            renderLogEntries();
            clearCurrentResponse();
            saveToLocalStorage();
            
            // Open drawer and show log tab
            drawer.classList.add('open');
            drawerToggle.classList.add('active');
            switchTab('log');
        }

        // Render Log Entries
        function renderLogEntries() {
            if (logEntries.length === 0) {
                logEntriesContainer.innerHTML = '<div class="empty-state">No entries yet. Start by selecting a mental model and responding.</div>';
                return;
            }

            logEntriesContainer.innerHTML = '';
            logEntries.forEach(entry => {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${entry.phase}`;
                logEntry.draggable = true;
                logEntry.dataset.entryId = entry.id;
                logEntry.innerHTML = `
                    <div class="log-entry-header">
                        <div class="log-model-name">${entry.modelName}</div>
                        <div class="log-actions">
                            <button class="log-action-btn" onclick="editEntry(${entry.id})" title="Edit">✏️</button>
                            <button class="log-action-btn" onclick="deleteEntry(${entry.id})" title="Delete">🗑️</button>
                        </div>
                    </div>
                    <div class="log-content">${entry.response}</div>
                    <div class="log-timestamp">${entry.timestamp}</div>
                `;

                // Add drag event listeners
                logEntry.addEventListener('dragstart', handleDragStart);
                logEntriesContainer.appendChild(logEntry);
            });
        }

        // Start Over - Save and Reset
        function startOver() {
            if (logEntries.length === 0 && notepadArea.classList.contains('empty')) {
                if (confirm('Start over? This will reset the app to the beginning.')) {
                    resetApp();
                }
                return;
            }
            
            // Prompt to save work before resetting
            const shouldSave = confirm('Would you like to save your decision-making session before starting over?\n\nClick OK to download a text file with all your work, or Cancel to start over without saving.');
            
            if (shouldSave) {
                downloadSession();
            }
            
            // Confirm reset
            const shouldReset = confirm('Ready to start over? This will clear all your entries and reset the app.');
            if (shouldReset) {
                resetApp();
            }
        }

        // Download Session as Text File
        function downloadSession() {
            let content = 'MENTAL MODELS DECISION-MAKING SESSION\n';
            content += '=' .repeat(60) + '\n';
            content += `Date: ${new Date().toLocaleString()}\n\n`;
            
            // Add problem description if exists
            const problemEntry = logEntries.find(e => e.phase === 'initial');
            if (problemEntry) {
                content += 'PROBLEM/DECISION:\n';
                content += problemEntry.response + '\n\n';
                content += '=' .repeat(60) + '\n\n';
            }
            
            // Add all mental model responses grouped by phase
            const phases = ['diagnostic', 'evaluative', 'protective', 'generative', 'implementation'];
            const phaseNames = {
                diagnostic: 'DIAGNOSTIC PHASE',
                evaluative: 'EVALUATIVE PHASE',
                protective: 'PROTECTIVE PHASE',
                generative: 'GENERATIVE PHASE',
                implementation: 'IMPLEMENTATION PHASE'
            };
            
            phases.forEach(phase => {
                const phaseEntries = logEntries.filter(e => e.phase === phase);
                if (phaseEntries.length > 0) {
                    content += phaseNames[phase] + '\n';
                    content += '-'.repeat(60) + '\n\n';
                    
                    phaseEntries.forEach(entry => {
                        content += `${entry.modelName}:\n`;
                        content += `${entry.response}\n`;
                        content += `(${entry.timestamp})\n\n`;
                    });
                    
                    content += '\n';
                }
            });
            
            // Add notepad content if not empty
            if (!notepadArea.classList.contains('empty')) {
                content += '=' .repeat(60) + '\n';
                content += 'COMPILED NOTES:\n';
                content += '=' .repeat(60) + '\n\n';
                content += (notepadArea.innerText || notepadArea.textContent) + '\n';
            }
            
            // Create and download file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `decision-session-${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Reset App to Initial State
        function resetApp() {
            // Clear all data
            logEntries = [];
            nextLogId = 1;
            problemDescribed = false;
            problemType = null;
            selectedModel = null;
            currentPhase = 'diagnostic';
            
            // Clear localStorage
            localStorage.removeItem('mentalModelsLog');
            
            // Reset UI
            responseInput.value = '';
            notepadArea.innerText = 'Drag log entries here to compile your thinking...';
            notepadArea.classList.add('empty');
            renderLogEntries();
            
            // Hide problem reference and type selector
            problemReference.classList.remove('visible');
            problemReferenceText.textContent = '';
            problemTypeSelector.classList.remove('visible');
            continueBtn.classList.remove('visible');
            
            // Hide sections again
            phaseNavigation.classList.remove('revealed');
            modelsSection.classList.remove('revealed');
            workArea.classList.remove('slide-down');
            
            // Close drawers
            drawer.classList.remove('open');
            drawerToggle.classList.remove('active');
            
            // Reorder DOM back to initial state (work area first)
            mainContent.insertBefore(workArea, phaseNavigation);
            
            // Reset to initial prompt
            showInitialPrompt();
            updatePhaseButtons();
            renderPhaseContent();
        }

        // Clear Current Response (just the textarea)
        function clearCurrentResponse() {
            responseInput.value = '';
            responseInput.focus();
        }

        // Edit Entry
        window.editEntry = function(id) {
            const entry = logEntries.find(e => e.id === id);
            if (!entry) return;

            const newResponse = prompt('Edit your response:', entry.response);
            if (newResponse !== null && newResponse.trim()) {
                entry.response = newResponse.trim();
                entry.timestamp = new Date().toLocaleString() + ' (edited)';
                renderLogEntries();
                saveToLocalStorage();
            }
        };

        // Delete Entry
        window.deleteEntry = function(id) {
            if (confirm('Delete this entry?')) {
                logEntries = logEntries.filter(e => e.id !== id);
                renderLogEntries();
                saveToLocalStorage();
            }
        };

        // Drag and Drop Handlers
        function handleDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', e.target.dataset.entryId);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            notepadArea.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (e.target === notepadArea) {
                notepadArea.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            notepadArea.classList.remove('drag-over');

            const entryId = parseInt(e.dataTransfer.getData('text/plain'));
            const entry = logEntries.find(e => e.id === entryId);
            
            if (entry) {
                const currentContent = notepadArea.classList.contains('empty') ? '' : (notepadArea.innerText || notepadArea.textContent);
                
                // Format the new entry
                const newEntryText = `${entry.modelName}:\n${entry.response}\n${'-'.repeat(60)}\n\n`;
                
                // If notepad is empty, just add the entry
                if (notepadArea.classList.contains('empty')) {
                    notepadArea.innerText = newEntryText.trim();
                } else {
                    // If there's a problem description section, append after the divider
                    if (currentContent.includes('MENTAL MODEL RESPONSES:')) {
                        notepadArea.innerText = currentContent + newEntryText;
                    } else {
                        // Otherwise just append
                        notepadArea.innerText = `${currentContent}\n\n${newEntryText}`;
                    }
                }
                
                notepadArea.classList.remove('empty');
            }
        }

        // Clear Notepad
        function clearNotepad() {
            if (notepadArea.classList.contains('empty')) {
                return;
            }
            
            if (confirm('Clear notepad? This will remove all compiled responses but keep your problem description in the log.')) {
                // If there's a problem description saved, keep it
                if (problemDescribed) {
                    const problemEntry = logEntries.find(e => e.phase === 'initial');
                    if (problemEntry) {
                        notepadArea.innerText = `PROBLEM/DECISION:\n${problemEntry.response}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
                        notepadArea.classList.remove('empty');
                    } else {
                        notepadArea.innerText = 'Drag log entries here to compile your thinking...';
                        notepadArea.classList.add('empty');
                    }
                } else {
                    notepadArea.innerText = 'Drag log entries here to compile your thinking...';
                    notepadArea.classList.add('empty');
                }
            }
        }

        // Copy Notepad
        function copyNotepad() {
            if (notepadArea.classList.contains('empty')) {
                alert('Notepad is empty.');
                return;
            }

            const text = notepadArea.textContent || notepadArea.innerText;
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                const originalBorder = notepadArea.style.borderColor;
                notepadArea.style.borderColor = '#4CAF50';
                setTimeout(() => {
                    notepadArea.style.borderColor = originalBorder;
                }, 500);
            }).catch(() => {
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        // Local Storage
        function saveToLocalStorage() {
            localStorage.setItem('mentalModelsLog', JSON.stringify({
                entries: logEntries,
                nextId: nextLogId
            }));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('mentalModelsLog');
            if (saved) {
                const data = JSON.parse(saved);
                logEntries = data.entries || [];
                nextLogId = data.nextId || 1;
                
                // Check if problem was already described
                const hasProblemDescription = logEntries.some(e => e.phase === 'initial');
                if (hasProblemDescription) {
                    problemDescribed = true;
                    revealSections();
                    
                    // Restore notepad with problem description
                    const problemEntry = logEntries.find(e => e.phase === 'initial');
                    if (problemEntry) {
                        // Show problem reference banner
                        problemReferenceText.textContent = problemEntry.response;
                        problemReference.classList.add('visible');
                        
                        notepadArea.innerText = `PROBLEM/DECISION:\n${problemEntry.response}\n\n${'='.repeat(60)}\n\nMENTAL MODEL RESPONSES:\n\n`;
                        notepadArea.classList.remove('empty');
                    }
                }
                
                renderLogEntries();
            }
        }

        // Initialize App
        init();
    </script>
</body>
</html>
